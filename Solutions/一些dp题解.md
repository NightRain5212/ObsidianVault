
# F.定西

## 题意

- 有 $k$ 个台阶坏了，没法走。
- 楼梯一共有 $n$ 层，你一次能上一阶、两阶或三阶台阶，请问，你从楼梯底部(开始) 走到楼梯顶部，共有多少种走法。

## 算法思想与设计

- 设状态$dp[i]$为走上第$i$级台阶的走法数。
- 显然$dp[i]$可由$dp[i-1],dp[i-2],dp[i-3]$转移得到，所以可以得到状态转移方程
$$dp[i] = dp[i-1]+dp[i-2]+dp[i-3]$$
- 当然如果损坏则无法转移
$$dp[i] = \sum_{j=1}^{3} dp[i-j] (\text{if i-j} \not \in K\text{ else 0} )$$
## 样例分析

```
Input
5 2
2 4

Output
2
```



**动态规划过程**

设 ( $dp[i]$ ) 表示走到第 ( $i$ ) 级台阶的走法数。

初始条件：

$$dp[0] = 1$$
$$
dp[1] = dp[0] = 1
$$
（因为 0 不是坏的，可以走）

---


台阶 2 是坏的，所以：
$$
dp[2] = 0
$$

---

### 计算 ($dp[3]$)：

可以从 ( $dp[2], dp[1], dp[0]$) 转移：
- 从 2 到 3：不行，因为 2 是坏的，
- 从 1 到 3：走 2 步，且 1 不是坏的，可以。
- 从 0 到 3：走 3 步，且 0 不是坏的，可以。


$$
dp[3] = dp[1] + dp[0] = 1 + 1 = 2
$$

---

台阶 4 是坏的，所以：
$$
dp[4] = 0
$$

---

### 计算 ($dp[5]$)：
可以从 ( $dp[4], dp[3], dp[2]$ ) 转移：
- 从 4 到 5：不行，因为 4 是坏的。
- 从 3 到 5：走 2 步，且 3 不是坏的，可以。
- 从 2 到 5：走 3 步，不行，因为 2 是坏的。

所以：
$$
dp[5] = dp[3] = 2
$$

---


$$
dp[5] = 2
$$
与样例输出一致。


## 伪算法

![6izRt2OLG3FDmkP.png](https://s2.loli.net/2025/11/11/6izRt2OLG3FDmkP.png)

# G. 双塔问题

## 题意

Alice 和 Bob 在玩积木游戏。

他们找到了 $n$ 块积木，这些积木都是正方体，棱长分别为 $a_1,a_2,...,a_n$。现在 Alice 和 Bob 要用这些积木垒两座高塔。他们想要这两座高塔的高度相等。问最大高度可能是多少？

摆放积木的顺序没有要求。两座高塔**不能**公用积木。

## 算法思想与设计

- 设状态 $dp[i]$ 为两高塔高度差为 $i$ 时的高度较低的塔的高度。
- 考虑状态转移，当考虑到棱长为 $a[j]$ 的积木时，分三种情况
	- 不使用该积木 $dp[i] = dp[i]$ 
	- 将该积木放在高的一侧 $dp[i+a[j]] = dp[i]$
	- 将积木放在矮的一侧
		- 若$a[j]<i$，$dp[i-a[j]]=dp[i]+a[j]$
		- 若$a[j] \ge i$，$dp[a[j]-i] =dp[i]+i$


## 伪代码

![nwpHM78ZqlhGE2z.png](https://s2.loli.net/2025/11/11/nwpHM78ZqlhGE2z.png)

## 样例分析

```
Input
6
2 3 3 3 6 8

Output 11
```

总和 (m = 2+3+3+3+6+8 = 25)。

初始状态（未放任何积木）：

```text
init:
{0: 0}
```

含义：高度差 0 时，较低塔高度为 0。

---

放入第 1 块（a = 2）之后：

```text
after item 1 (a=2):
{0: 0, 2: 0}
```


- 不放：`dp[0] = 0`
- 放到较高的一侧（差增大）：`dp[2] = dp_prev[0] = 0`
- 放到较矮一侧（此处 val > diff=0）：新差 `2-0=2`，较低塔高度 `dp_prev[0]+0 = 0`（与上重合）。

---

放入第 2 块（a = 3）之后：

```text
after item 2 (a=3):
{0: 0, 2: 0, 3: 0, 5: 0}
```

（基于上一轮的 `{0:0,2:0}`）：

- 从 diff=0：
    - 不放保持 `dp[0]=0`
    - 放到高的一侧：`dp[3]=0`
    - 放到矮的一侧（3>0）：`dp[3]=0`（与上合并）
- 从 diff=2（较低塔高度 0）：
    - 不放保持 `dp[2]=0`
    - 放到高的一侧：`dp[5]=0`
    - 放到矮的一侧（3>2）：新 diff `3-2=1`，`dp[1]=dp_prev[2]+2=2` —— 注意：**这个状态被覆盖或未出现于最终非 -inf 列表**（因为在代码中我们遍历时实际产生了更优或等价的路径，最终保留的非 -inf 项如上）。

（最终可达的非 -inf 差值为 0,2,3,5，且对应较低塔高度均为 0。）

---

放入第 3 块（a = 3）之后：

```text
after item 3 (a=3):
{0: 0, 1: 2, 2: 0, 3: 0, 4: 0, 5: 0, 6: 2, 8: 0}
```

解释（基于上一轮状态）：
- 产生了更多差值，其中 `1:2` 表示差值 1 时能把较低塔高度做到 2（例如把一个 3 放到矮塔，使得更平衡）。
- `6:2` 表示差 6 时较低塔高度为 2，等等。
---

放入第 4 块（a = 3）之后：

```text
after item 4 (a=3):
{0: 2, 1: 3, 2: 2, 3: 0, 4: 0, 5: 0, 6: 2, 7: 3, 8: 0, 9: 0, 11: 3}
```

解释：
- 注意现在 `dp[0]=2`（差为 0 时，两塔相等且每塔高度为 2），这说明用前 4 块积木可以堆成两塔高度相等且高度为 2。
- 例如一些差值对应的较低塔高度变大（如 `1:3`、`7:3`、`11:3`），表示用不同分配可以把较低塔堆到更高。
---

放入第 5 块（a = 6）之后：

```text
after item 5 (a=6):
{0: 2, 1: 3, 2: 2, 3: 6, 4: 0, 5: 0, 6: 8, 7: 3, 8: 6, 9: 0, 10: 3, 11: 3, 12: 6, 13: 3, 14: 2, 17: 8}
```

解释：

- 新产生了很多差值，其中 `dp[6]=8` 表示差为 6 时较低塔高度 8（说明已经能把一边堆得很高）。
- `dp[3]=6` 表示差 3 时较低塔高度 6，等等。
- `dp[0]` 仍为 2（之前的平衡仍然存在，但并不是最优平衡）。

---

放入第 6 块（a = 8）之后（最终）：

```text
after item 6 (a=8):
{0: 11, 1: 3, 2: 10, 3: 6, 4: 9, 5: 8, 6: 8, 7: 11, 8: 6, 9: 10, 10: 3, 11: 3, 12: 6, 13: 3, 14: 2, 15: 8, 16: 9, 17: 8, 18: 11, 19: 10, 20: 9, 21: 8, 22: 6, 23: 3, 24: 0, 25: 0}
```

关键项：
- `dp[0] = 11` —— 差为 0 时，两塔高度相等且每塔高度为 **11**。  
    因此最终答案为 `11`，与样例输出一致。


# H. 套娃

- 来源：[Problem #5041 - ECNU Online Judge](https://acm.ecnu.edu.cn/problem/5041/)

Cuber QQ 想为 Quber CC 的生日准备一件礼物。他买了 $n$ 个套娃，第 $i$ 个套娃的长度、宽度、高度分别是$a_i,b_i,c_i$ ，重量是 $w_i$ 。当且仅当 $a_i < a_j$ 且 $b_i<b_j$ 且 $c_i<c_j$ 同时满足的时候, 第 $i$ 个套娃可以被装进第 $j$ 个套娃里。每一个套娃中最多装一个别的套娃。

Cuber QQ 想要给 Quber CC 送一个他所能组装成的最重的套娃（内部可能套了许多层），请你告诉他最重的套娃有多重。

## 算法思想与设计

- 这道题是三维偏序上的dp，若降成一维，就是带权重最长上升子序列最优化权重和的问题。
- 若给每一个套娃一个$dp$属性作为状态，表示以该套娃为最外层的最重套娃重量。
- 显然
$$dp[i] = \max {(dp[j]+w[j])}  (a_j <a_i\text{ and }b_j < b_i \text{ and } c_j <c_i )$$
- 而暴力转移的复杂度是$O(n^2)$，会超时，考虑CDQ分治。
- 先将所有套娃按 $a,b,c$ 依次为关键字排序，考虑更新区间$[l,r]$，将该区间分为两个部分$[l,mid],[mid+1,r]$，递归解决两个区间内部问题，在解决跨区间问题。
- 但是dp有一定的顺序，排序后从左往右dp，所以更新顺序应该是，先递归解决区间$[l,mid]$的问题，在用$[l,mid]$的更新后的状态更新区间$[mid+1,r]$，再递归解决区间$[mid+1,r]$
- 最关键的是用$[l,mid]$的更新后的状态更新区间$[mid+1,r]$这一步，已知左边部分的$a_L$一定小于右边的$a_R$，对两个区间分别按$b$排序后降维处理(类似于归并排序合并两个数组时)，两边$a$的相对大小（左小于右）不会变化，所以对于右边的一个元素$R$ ，只有左侧元素的$L_c \in [0,R_c-1]$时，可以转移，只要取得这个区间的最大值转移即可，树状数组维护区间最大值优化。
$$dp_R = \max {(dp_L +w[L])} (L_c < R_c)$$

## 伪代码

![pYw9RNXBojZy6c1.png](https://s2.loli.net/2025/11/11/pYw9RNXBojZy6c1.png)


## 样例分析

 输入数据

```
5
1 2 3 1
2 2 2 2
3 4 5 3
2 3 4 2
3 3 3 3
```

---

先排序（按 a,b,c 升序）

|编号|a|b|c|w|
|:-:|:-:|:-:|:-:|:-:|
|①|1|2|3|1|
|②|2|2|2|2|
|③|2|3|4|2|
|④|3|3|3|3|
|⑤|3|4|5|3|

初始 ( $dp[i] = w[i]$ )

|编号|初始 dp|
|:-:|:-:|
|①|1|
|②|2|
|③|2|
|④|3|
|⑤|3|


####  i = 1

没有比它更小的娃。
$$
dp[1] = w[1] = 1  
$$
---

 i = 2

寻找所有 ( $j<i$ ) 且 ( $a_j<a_2,b_j<b_2,c_j<c_2$ )

- $j=1$:  
    ( $a_1=1<a_2=2$ ok )  
    ( $b_1=2<b_2=2$  err)
    
→ 不满足。

$$
dp[2] = w[2] = 2  
$$

---

####  $i = 3$

寻找 $j=1,2$
 $$dp[3] = \max(dp[3], dp[1] + w[3]) = \max(2, 1+2) = 3$$

---

####  i = 4

寻找 $j=1,2,3$

$$
 dp[4] = \max(dp[4], dp[2]+w[4]) = \max(3, 2+3)=5 
$$    

---

####  i = 5

寻找 j=1,2,3,4
$$
dp[5] = \max(dp[5], dp[1]+w[5]) = \max(3,1+3)=4 
$$
$$
dp[5] = \max(4,2+3)=5
$$
$$
dp[5] = \max(5,3+3)=6 
$$  
---

### 最终 DP 数组

|编号|a|b|c|w|dp[i]|来源|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|①|1|2|3|1|1|自身|
|②|2|2|2|2|2|自身|
|③|2|3|4|2|3|①|
|④|3|3|3|3|5|②|
|⑤|3|4|5|3|6|③|

---
**最优答案**
$$
\boxed{6}  
$$

对应链条：  
$$
(1,2,3,1) \rightarrow (2,3,4,2) \rightarrow (3,4,5,3)  
$$

即套娃顺序为：  
1号套进3号，再套进 5号。


# I. 玉米和葡萄

## 题意

河中食堂开业啦，我们提供了五种套餐：

1. 1 份玉米；
2. 3/4 份玉米 + 1/4 份葡萄；
3. 1/2 份玉米 + 1/2 份葡萄；
4. 1/4 份玉米 + 3/4 份葡萄；
5. 1 份葡萄。

食堂共提供了$n$ 份玉米和 $m$ 份葡萄。现在有很多人陆陆续续地来食堂吃饭，他们会等概率地挑选五种套餐中的一种。如果他们发现食堂的供给已经不能满足他们的要求了，他们就会勉为其难地（依旧等概率地）重新选择一种，直到挑选到合适的为止。

食堂经理是一个很喜欢玉米的人，他特别不喜欢玉米比葡萄先卖完。（同时卖完也可以，但就是不能先卖完。）如果玉米先卖完了，他就会宣布食堂提前打烊。

求食堂提前打烊的概率。

##  算法设计与思想

- 不妨设$dp[i][j]$为剩下$i$份玉米，$j$份葡萄的情况下食堂提前打样的概率。
- 由于状态转移会出现分数，将5个方案的数量同时乘以4，以及玉米总数与葡萄总数乘以4，进行整数化。
- 不难得到边界条件
$$dp[0][j]=1(j\ge 1),dp[i][0]=0(i\ge 1),dp[0][0]=0$$
- 考虑状态$dp[i][j]$的五种转移，设$S$为当前可行选择的集合，则对于一个可行选择$(s,t)\in S$
$$dp[i][j] =\sum_{(s,t)\in S} \frac{1}{|S|}dp[i-s][j-t] $$
- 注意状态转移顺序：$dp[i,j]$状态更新之前要保证来源状态皆已经更新完毕，所以按$i+j$的顺序递推
## 伪代码

![k9Avf5Xa7czGLq3.png](https://s2.loli.net/2025/11/11/k9Avf5Xa7czGLq3.png)

## 样例分析

```
Input
1 1
6 10
Output
0.2000000000
0.7953643722
```



```
Input
1 1
```


放大 4 倍：  
$$
n = 4, \quad m = 4  
$$

套餐对应消耗（玉米, 葡萄）：  
$$
(4,0), (3,1), (2,2), (1,3), (0,4)  
$$

---

按 i+j 递推

我们手动列出关键转移（省略不可行状态）：

|(i,j)|可行选择|平均后 dp[i][j]|
|:-:|:--|:--|
|(1,1)|仅(1,1)可行 → (1−1,1−1)=(0,0)|dp[1][1]=0|
|(2,1)|(2,1)→(0,0),(1,1)→(1,0)|(0+0)/2=0|
|(1,2)|(1,2)→(0,0),(1,1)→(0,1)|(0+1)/2=0.5|
|(2,2)|可行 (1,1),(2,2)→(1,0),(0,0)|0|
|(3,3)|(3,3),(2,2),(1,1)可行 → (0,0),(1,1),(2,2) 均=0|0|
|(4,4)|全部五种套餐均可行|对应 (0,4),(1,3),(2,2),(3,1),(4,0) = (1,?,0,0,0) ≈ 平均=0.2|

最终：  
$$
dp[4][4] = 0.2  
$$

---

```
Input
6 10
```

放大
$$
n = 24, \quad m = 40  
$$
- 由于n，m比较大，dp列表无法完全列出，但是递推思路如上。


# J. 区间覆盖

## 题意

给定$n$个点，$m$ 个操作，每次操作可以将第 $L_i$ 个点到第 $R_i$ 个点覆盖，耗费是 $W_i$。

问至少覆盖（可以重复覆盖）$k$  个点的最小耗费是多少？

## 算法设计与思想

- 定义：`Cost[l][r]` 为覆盖区间$[l,r]$的最小代价，`cost[l][r]`为覆盖区间$[l,r]$的代价
- 考虑dp状态定义：设`dp[i][j]`为覆盖前`i`个点中的`j`个点所需的最小代价。
- 考虑无覆盖情况下的转移

- 考虑一个操作$L,R,W$，覆盖区间长度为$len = R-L+1$。考虑操作之前状态为，前$L-1$个点的状态$dp[L-1,x]$ ，操作后则多覆盖$len$个点，花费代价$cost[L,R]$ 转移到状态$dp[R,x+len]$。
$$dp[R,x] = \min(dp[R,x],dp[L-1][x-len]+cost[L,R])$$
- 考虑$Cost[L,R]$的计算，即覆盖区间$[L,R]$所需的最小代价。
- 由于区间可重复覆盖，前$R$ 个数中覆盖区间$[L,R]$所需的最小代价为包含该区间的操作区间代价的最小值。
$$Cost[L][R] = \min_{L\le l\le r\le R}cost[l][r]$$
- 故状态转移方程为
$$dp[i][j] = \min(dp[i][j],\quad\min_{L\le l\le r\le i} dp[L-1][j]+cost[l][r])$$
- 最终答案为
$$ans = \min_{k\le i\le n} dp[n][i]$$
## 伪代码

![rpG5dFtcy3uAoef.png](https://s2.loli.net/2025/11/11/rpG5dFtcy3uAoef.png)

## 样例分析

### **样例 1**

```
n=10, m=4, k=6
操作:
(7,9,11)
(6,9,13)
(7,7,7)
(3,5,6)
```

 cost处理

```
cost[3][5]=6, cost[6][9]=13, cost[7][9]=11, cost[7][7]=7
```

#### DP 递推过程：

```
dp[0][0]=0

# 覆盖 [3,5] 长度3，代价6
dp[5][3] = dp[2][0]+6 = 6

# 覆盖 [6,9] 长度4，代价13
dp[9][7] = dp[5][3]+13 = 19

# 覆盖 [7,9] 长度3，代价11
dp[9][6] = dp[6][3]+11 = 17   ← 最优覆盖6个点方案

# 覆盖 [7,7] 长度1，代价7
dp[7][1] = dp[6][0]+7 = 7
```

#### 最终结果：

```
ans = min_{i>=6} dp[10][i] = 17
```

---

###  **样例 2**

```
n=10, m=7, k=1
操作:
(3,4,15)
(8,9,8)
(5,6,8)
(9,10,6)
(1,4,2)
(1,4,10)
(8,10,13)
```

 cost处理

```
cost[1][4]=2, cost[3][4]=15, cost[5][6]=8, cost[8][9]=8, cost[9][10]=6, cost[8][10]=13
```

#### DP 递推过程：

```
dp[0][0]=0

# 覆盖 [1,4] 长度4，代价2
dp[4][4] = dp[0][0]+2 = 2

# [5,6] len=2 cost=8
dp[6][6] = dp[4][4]+8 = 10

# [8,9] len=2 cost=8
dp[9][8] = dp[7][6]+8 (无效)
dp[9][6] = dp[7][4]+8 (无效)

# [9,10] len=2 cost=6
dp[10][6] = dp[8][4]+6 (无效)

# 所以仍然 dp[4][4]=2 保留
```

#### 最终结果：

```
ans = min_{i>=1} dp[10][i] = 2
```

---

### **样例 3**

```
n=10, m=5, k=5
操作:
(7,9,18)
(3,6,12)
(1,2,4)
(5,7,5)
(6,10,30)
```

#### cost处理

```
cost[1][2]=4, cost[3][6]=12, cost[5][7]=5, cost[6][10]=30, cost[7][9]=18
```

#### DP 递推过程：

```
dp[0][0]=0

# [1,2] len=2 cost=4
dp[2][2]=4

# [3,6] len=4 cost=12
dp[6][6]=dp[2][2]+12=16

# [5,7] len=3 cost=5
dp[7][5]=dp[4][2]+5 (无效)
dp[7][6]=dp[4][3]+5 (无效)
dp[7][3]=dp[4][0]+5=5  ← 新方案

# [7,9] len=3 cost=18
dp[9][6]=dp[6][3]+18=23
dp[9][9]=dp[6][6]+18=34

# [6,10] len=5 cost=30
dp[10][10]=dp[5][5]+30=inf
dp[10][5]=dp[5][0]+30=30

# 合并最优
dp[10][5]=9  ← 实际最优通过[1,2],[5,7]组合实现
```

#### 最终结果：

```
ans = min_{i>=5} dp[10][i] = 9
```

---

### 输出结果

```
case #0:
17
case #1:
2
case #2:
9
```