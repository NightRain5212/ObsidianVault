
# A.简单排序题

##  题意：

- 给出整数数列$a_n$，对整个数列进行尽可能少的次数操作，每次操作可以将数列中任意一项加1或者减1，使得最终的数列$b_1,b_2,b_3,...,b_n$满足对数列中的任一项$b_i(i>=2)$,有$b_i=b_{i-1}十i$。
- 输入格式
	- 一行一个数字$n(1≤n≤100000)$.代表$a_n$的总长度。接下来$n$个数字，代表这个数列中的第一项开始依次的$a_1,a_2,...,a_n$的值。$1≤a≤10^{10}$。

## 样例

```
3
8626928508 565605673 8384653443
```

```
8061322837
```

## 题解思想及设计

- 观察目标数列$b_i -b_{i-1} = i$，$b_i = b_1 +2+3+...+i = b_1 +\frac{(2+i)(i-1)}{2}$
- 因此只要确定了第一项的值，这个数列就确定了。
- 每一项的操作次数为
$$|a_i-b_i|=|a_i-b_1 -\frac{(2+i)(i-1)}{2}|=|a_i-\frac{(2+i)(i-1)}{2}-b_1|$$
- 答案所求为
$$\min (\sum |a_i-\frac{(2+i)(i-1)}{2}-b_1|)$$
- 不难发现构造一个新数列$c_i = a_i-\frac{(2+i)(i-1)}{2}$，后答案所求即为
$$\min (\sum |c_i-b_1|)$$
- 我们 要给 $b_1$ 一个值使得答案最小，显然为$\{c_i\}$的中位数即可。

## 伪代码

![](https://s2.loli.net/2025/10/25/BcML49JpHPZ3sev.png)

## 结合样例分析

输入
```
3 
8626928508 565605673 8384653443
```
转化成新数列
```
8626928508 565605671 8384653438
```
排序后取中位数`8384653438`

计算答案为 `8061322837` 符合预期


# B.SBT

## 题意：

一个城镇中会有座房子，每个房子的温度可以表示为$s_i$，SBT中不存在温度高于30的房子，不存在温度低于10的房子，而且任意两座房子的温度差距不超过3。给定一个城镇的信息，请判断这座城镇是不是SBT。

## 样例

```
3
10 11 12
2
-10 40
3
11 13 15
```

```
Is SBT
Is not SBT
Is not SBT
```
## 题解思想及设计

- 对 $s_i$ 排序后，首项和尾项就是最小温度和最大温度的房子，判断是否满足条件。
- 任意两座房子的温度差最大就是首项和尾项之差，判断是否满足条件即可。

## 伪代码

![](https://s2.loli.net/2025/10/25/HY32EvDouA5N67b.png)

## 样例分析

```
10 11 12
```
- $10\ge10,12\le 30,12-10=2\le3$，是SBT

```
-10 40
```
- $40 > 30$，不是SBT

```
11 13 15
```
- $15-11=4 > 3$，不是SBT

# C


## 题意：

计算集合A和集合B的交集C、并集D和差集E。集合的元素值均为整数，集合A和集合B的元素个数均不大于1000。集合A和集合B可能是空集。

- 输入格式
	- 第1行由两个用一个空格分隔的整数组成，分别是集合A和集合B的元素个数。
	- 第2行由用一个空格分隔的若干整数组成（空集时为空行），表示集合A的每个元素值。
	- 第3行由用一个空格分隔的若干整数组成（空集时为空行），表示集合B的每个元素值。
- 输出格式
	- 共有3行，分别表示集合C、集合D和集合E。一个集合的输出以左花括号开头，右花括号束。中间显示的集合元素按升序排列，元素之间包含一个逗号。空集时输出为`{}`。

## 样例

```
5 6
1 2 3 4 5
15 14 13 12 11 10
```

```
{}
{1,2,3,4,5,10,11,12,13,14,15}
{1,2,3,4,5}
```

## 题解思想及设计

- 对于两个数组，各维护一个记录元素出现次数的桶。
- 交集：每一个一个元素在两桶中出现次数均大于1
- 并集：两个桶中出现次数大于1的元素
- 差集：一个桶中出现次数大于1，另一个为0

## 伪代码

![](https://s2.loli.net/2025/10/25/teE1jXI8Lg6acJw.png)


## 样例分析

```
1 2 3 4 5
15 14 13 12 11 10
```

交集：没有元素在两桶中出现次数均大于1，故为空
并集：两个桶中出现次数大于1的元素为
```
1 2 3 4 5 15 14 13 12 11 10
```
差集：A的所有元素在B的桶中计数均为0
```
1 2 3 4 5
```


# D.陌上花开

## 题意：

有$n$ 个元素，第 $i$ 个元素有 $a_i,b_i,c_i$ 三个属性，设 $f(i)$ 表示满足  $a_j \leq a_i$ 且 $b_j \leq b_i$ 且 $c_j \leq c_i$且 $j \ne i$ 的 $j$ 的数量。

对于 $d \in [0, n)$，求 $f(i) = d$ 的数量。

## 输入格式

第一行两个整数 $n,k$，表示元素数量和最大属性值。

接下来  $n$ 行，每行三个整数 $a_i ,b_i,c_i$，分别表示三个属性值。

## 输出格式

$n$ 行，第 $d + 1$ 行表示 $f(i) = d$ 的 $i$ 的数量。

## 样例

```
10 3
3 3 3
2 3 3
2 3 1
3 1 1
3 1 2
1 3 1
1 1 2
1 2 2
1 3 2
1 2 1
```

```
3
1
3
0
1
0
1
0
0
1
```


$1 \leq n \leq 10^5$，$1 \leq a_i, b_i, c_i \le k \leq 2 \times 10^5$

## 题解思想及设计

- 这是一个**三维偏序**问题。
- 首先考虑**二维偏序**问题，两个关键字$(x,y)$，如果先按 $x$ 从低到高排序，那就相当于**降了一维**，接下来解决一维偏序问题。
- 对于一维偏序问题，一个数组$a_1,a_2,...,a_n$，对于每一个$i$，统计有多少个$a_j\le a_i$的$j$的数量。若$a_1<a_2<...<a_n$，则可以使用树状数组维护每个元素出现的次数$c[N]$，从$a_1$到$a_n$遍历，每遍历一个元素，更新对应的出现次数，然后询问答案即为前缀和$c[1]+...+c[a_i]$，即为树状数组的一次查询。
- 回到二维偏序，先以$x$作为第一关键字排序，$y$作为第二关键字排序。排序完后，处理一维偏序即可。
- 对于三维偏序$(x,y,z)$，先以$x$作为第一关键字排序，$y$作为第二关键字排序，$z$作为第三关键字排序。若此时化为二维偏序，对$y$排序，**会破坏原有**的 $x$ 的**顺序**，因此采用**CDQ分治**的思想解决问题。
- 先以$x$作为第一关键字排序，$y$作为第二关键字排序，$z$作为第三关键字排序。然后将元素集分为两部分，$[1,mid],[mid+1,n]$，其中对于每一个部分而言，**将问题划分成了两个同样的子问题，可以通过递归解决**。对于跨部分的答案，在递归解决完两个子部分后合并时解决。
- 假设区间$[l,mid],[mid+1,r]$已经通过递归解决，合并时，左边部分的$x$值一定小于右边，因此**只有左边部分的元素对右边部分的元素答案有贡献**。在两个部分中分别对$y$进行排序，此时因为左边部分的$x$值一定小于右边，所以不会破坏$x$值的左右部分相对顺序。
- 这个时候按照处理归并排序的合并思想类似（处理一维偏序），用一个数组$c[N]$维护左边部分元素的出现次数，使用双指针$pl,pr$ ，$pr$从头到尾遍历，对于遍历到的每一个元素$R_{pr}$，若$pl$指向的元素$L_{pl}.y \le R_{pr}.y$，更新$c[L_{pl}]$，$pl$指针接着向后遍历，直到$L>R$。遍历完左指针后更新$R$的答案$ans[R] = c[1]+c[2]+...+c[R]$。
- 细节问题：可能要先对原输入数据进行**去重和离散化**处理；每一次合并之后要**还原树状数组**。

## 伪代码

![](https://s2.loli.net/2025/10/25/fVhF9tbH7iqCmcI.png)


## 样例分析

![ranwPRVgNyKmT9h.jpg](https://s2.loli.net/2025/10/25/ranwPRVgNyKmT9h.jpg)
# E


## 题意：

前段时间 partychen 到吴泾去买东西，发现在步行街有一个赌博游戏，一个商人在地面上摆放了很多的小礼品，然后准备了很多大小相同的圆环，玩家可以到商人处花 5 块钱买一个圆环。然后站在一根白线外使用圆环套住自己想要的礼品。圆环套住的东西就归玩家所有。我这里描述的不是很清楚，但是我相信大家肯定也知道这个是什么游戏了。

出于商人的本性，他现在想邀请计算机的你，帮助他设计一个圆环，使得这个圆环最多只能套住一个小礼品。

为了让问题简单化，我们假设每一个小礼品都是平面上的一个点。如果点在圆环上也算套住。当然如果两个礼品重叠放置的话 那么圆环的半径显然会是 0。

他只要你求出这个圆环的半径。


给定平面上 $n$ 个点，找出其中的一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的。

## 输入格式

第一行：$n$ ，保证 $2\le n\le 200000$ 。

接下来 $n$ 行：每行两个整数：$x\ y$ ，表示一个点的行坐标和列坐标，中间用一个空格隔开。

## 输出格式

仅一行，一个实数，表示最短距离，精确到小数点后面 $4$ 位。

## 输入输出样例 #1

### 输入 #1

```
3
1 1
1 2
2 2
```

### 输出 #1

```
1.0000
```

## 说明/提示

数据保证 $0\le x,y\le 10^9$

## 样例

```
2
0 0
1 1
2
1 1
1 1
3
-1.5 0
0 0
0 1.5
0

```

```
0.71
0.00
0.75
```


## 题解思想及设计

- 依据题意，只要找到平面中最近的两个点的距离除以2即可。
- 使用CDQ分治找平面中最近的两点。
- 首先将所有的点按坐标$x$排序，**将点集划分为两部分**（以$x$处于中间的点为界），于是左右两个平面被划分为两个思想一致的子问题，递归求解得到左，右平面内的最小距离$d_{min} = min(L_{min},R_{min})$，还需考虑**跨左右平面**的最短距离是否会更小，以中点为基准，若一个点到中点$x,y$方向上距离比最短距离$d_{min}$还长，就不可能对答案做出贡献，于是找出所有可能对答案有贡献的点，计算他们的两两之间的距离，与$d_{min}$比较维护$d_{min}$即可


## 伪代码

![Nf8tnSIxQal5F9s.png](https://s2.loli.net/2025/10/25/Nf8tnSIxQal5F9s.png)

## 样例分析

```
0 0
1 1
```
直接算距离即可
```
sqrt(2)/2 = 0.71
```

```
1 1
1 1
```
直接算距离即可
```
0
```

```
-1.5 0
0 0
0 1.5
```
左半部分
```
1.5
```
右半部分
```
inf
```
合并
```
dmin = 1.5
```
对于候选，3个候选点最短距离仍是1.5，所以答案为
```
1.5
```