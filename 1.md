
####  题型与解题思路

- **题型归类**：多模式字符串匹配问题（Multi-pattern String Matching）。
- 解题思路：采用了 AC 自动机（Aho-Corasick Automaton） 算法。它结合了 字典树（Trie） 的结构优势和 KMP 算法 的失配指针（Fail Pointer）思想，能够在一个扫描过程中同时检测所有特征码，将时间复杂度优化至 $O(L + k)$（L为文本长度，k为匹配次数），极大地提升了检测效率。

##### 节点结构 (`struct Node`)

AC 自动机的基本单元是 Trie 树上的节点。


```cpp
struct Node {
    map<char,int> son; // 子节点映射
    int fail;          // 失配指针（Fail Pointer）
    vector<int> ids;   // 结束于该节点的规则ID列表

    Node() { fail=0; }
    // ...
};
```

- **`son` (`map<char,int>`)**：用于存储子节点。
- **`fail` (`int`)**：失配指针。指向当前状态的最长后缀节点。
- **`ids` (`vector<int>`)**：存储在该节点结束的所有规则 ID。

#####  AC 自动机类 (`class ACAutomaton`)

算法主要分为三个阶段：**构建（Insert）**、**预处理（Build）** 和 **匹配（Match）**，以及应对动态更新的 **重建（Rebuild）**。

##### **模式串插入 (Insert)**

- **逻辑**：将所有初始规则插入 Trie 树。
- **过程**：从根节点开始，遍历模式串字符。如果字符对应的子节点不存在，则新建节点；否则移动到子节点。在最后一个字符对应的节点上，将规则 ID 加入 `ids` 列表。
- **代码对应**：`ac.insert(rule_id, pattern)`。
    

##### **构建失配指针 (Build)**

- **逻辑**：通过广度优先搜索（BFS）计算每个节点的 `fail` 指针。
- **过程**：
    1. 根节点的子节点的 `fail` 指向根节点，入队。
    2. 取出队首节点 `u`，遍历其所有子节点 `i`（字符为 `ch`）。
    3. **寻找 Fail**：从 `u` 的 `fail` 指针 `p` 开始，不断回溯 `p = Trie[p].fail`，直到 `p` 拥有字符 `ch` 的子节点或回到根节点。
    4. **连接**：如果 `p` 有子节点 `ch`，则 `i` 的 `fail` 指向该子节点；否则指向根。
    5. 将 `i` 入队。
- **代码对应**：`ac.build()`。
    

##### **文本匹配 (Match)**

- **逻辑**：扫描数据包载荷（Payload），利用自动机状态转移进行检测。
- **过程**：
    1. 指针 `p` 从根节点开始。
    2. 读取文本字符 `c`。如果 `p` 没有对应子节点 `c`，则通过 `p = Trie[p].fail` 进行跳转（失配转移），直到找到匹配或回到根。
    3. 如果找到匹配，移动到子节点 `p = Trie[p].son[c]`。
    4. **收集结果**：这是关键一步。到达新状态 `p` 后，不仅检查 `p` 本身是否有输出（`ids`），还需要沿着 `fail` 指针向上遍历整个链路（`j = Trie[j].fail`）。这是因为如果匹配了长串（如 "she"），必然也匹配了其后缀存在的短串（如 "he"）。
    5. 计算起始位置：`pos = current_index - pattern_length + 1`。
- **代码对应**：`ac.match(payload)`。
    

##### **动态更新策略 (Rebuild)**

- **逻辑**：为了处理 `ADD_RULE` 和 `DEL_RULE`，算法采用了**全量重建**的策略。
- **原因**：AC 自动机的 `fail` 指针结构紧密依赖于所有模式串，增量更新极其复杂。鉴于本题规则变动频率低于每秒处理包的频率，重建是保证正确性最稳妥的方法。
- **过程**：清空 Trie -> 遍历所有标记为 `active` 的规则 -> 重新 Insert -> 重新 Build。
- **代码对应**：`ac.rebuild()`。
    

#### **实例演示**

假设规则库中有三个规则：

1. **he**
2. **she**
3. **his**

**构建过程**：

1. 构建 Trie 树：'h'-'e', 's'-'h'-'e', 'h'-'i'-'s'。
2. 构建 Fail 指针：
    - "she" 中的 'h' 节点，其 `fail` 指针会指向 "he" 中的 'h' 节点（因为 "sh" 的最长后缀是 "h"）。
    - "she" 中的 'e' 节点，其 `fail` 指针会指向 "he" 中的 'e' 节点（因为 "she" 的最长有效后缀是 "he"）。
        
匹配过程：
输入文本："ushers"
1. **u**：根节点无匹配，不动。
2. **s**：进入 's' 节点。
3. **h**：进入 "sh" 中的 'h' 节点。
4. **e**：进入 "she" 中的 'e' 节点。
    - **触发匹配**：发现该节点有输出 ID（规则 "she"）。
    - **Fail 回溯**：沿着 `fail` 指针跳到 "he" 的 'e' 节点，发现也有输出 ID（规则 "he"）。
    - **结果**：在同一位置检测到 "she" 和 "he"。
5. **r**：失配，跳转回根。
6. **s**：进入 's' 节点。

