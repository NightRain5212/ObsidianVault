

# 停机问题

- 假设存在程序`H`，以任何程序代码`P`，和其输入数据`I`作为输入，`H = (P,I)`,用于判断程序是否会停机
- 如果 `P` 在处理 `I` 时最终会**停止**（运行结束），输出 `True`。
- 如果 `P` 在处理 `I` 时会进入**死循环**（永远运行），输出 `False`。
```
H(P,I) {
	if(p(I)会停机) return 1;
	else return 0;
}
```


- 设计一个程序`U` 用一段源代码作为输入，它内部调用程序`H`的代码。（唱反调）
- 如果 `H` 说“会停机”，`U` 就故意进入**死循环**。
- 如果 `H` 说“会死循环”，U 就立刻**停机**。
```
U(P) {
	if(H(P,P))
		while(1);
	else 
		return;
}
```

- 现在将`U`本身的源代码作为输入,
```
U(U) {
	if(H(U,U))
		while(1);
	else 
		return;
}

H(U,U) {
	if(U(U)会停机) return 1;
	else return 0;
}
```
- 如果`H`判断U会停机，返回1，U进入死循环
- 防止，H判断为不会停机，返回0，U停机。
- 可知H的判断总是不正确，**因此不存在判断是否停机的方法。**

# 多项式时间算法

**定义：** 如果一个算法解决问题所需的时间 T(n)（通常指最坏情况下的步数），与输入规模 n 之间的关系可以用一个多项式来上界约束，即：
$$
T(n)=O(n^k)
$$
其中 k 是一个常数（比如 1, 2, 3...，但不能是 n）。 常见的有 $O(1),O(logn),O(n),O(nlogn),O(n^2),O(n^3)$ 等。

- **易解问题**：能够在多项式时间内解决的问题。
- **难解问题**：不存在多项式时间算法的问题。

# 多项式相关

假设两个函数$f,g:N\rightarrow N$，如果存在多项式$p,q$ ,
$$f(n)\le p(g(n)),\: g(n) \le q(f(n))$$
则，$f,g$是多项式相关的


# 判定问题

这是理论计算机科学中最基础的原子单位。

- **定义：** 输出结果 **只有“是 (Yes)”或“否 (No)”** 的问题。
- **例子：**
- “这个图里是否存在一条长度小于 100 的路径？”
- “这个数组里是否包含数字 7？”
- “这个逻辑公式是否有解？”


# 最优化问题

**定义：** 在所有可行解中，寻找一个**目标函数值最大或最小**的解。

**例子：**

- “请找出这个图里长度**最短**的那条路径是多少？”
- “请找出背包里能装下价值**最大**的物品组合。”


# P类问题

可以**在多项式时间内解决的判定问题**组成的问题类

# NP类

可以**在多项式时间内<u>验证</u>的判定问题**组成的问题类
- NP-非确定性多项式时间算法：把多项式时间验证算法看成一种以不确定的方式搜索整个证据空间：
* 对给定实例 $I \in D$，首先“猜想”一个 $t$，$|t| \le p(|I|)$ 
* 然后检查 $t$ 是否是证明 $I \in Y$ 的证据 
* 猜想和验证都可在多项式时间完成 
* $I \in Y \Leftrightarrow$ 能够正确地猜想到一个证据 $t$
* $P \subseteq NP$

## 哈密顿回路-NP问题

哈密尔顿回路(HC)的NP算法
**对于给定的图 $G$** 
* 任意猜想一个所有顶点的排列 
* 检查这个排列是否构成一条哈密尔顿回路 ，即任意相邻两点及首尾两点间是否都有边，若是， 回答“Yes”,否则回答 “No” 
* 上述猜想和验证都可在多项式时间内完成 
* 图 $G$ 可验证 $\Leftrightarrow$ 图 $G$ 存在哈密尔顿回路 
* 因此 $HC \in NP$

## 01背包-NP


- 给定 $n$ 个物品和一个背包，物品 $i$ 的重量为 $w_i$，价值为 $v_i$， $1 \le i \le n$，背包的重量限制为 $B$，目标价值为 $K$，问能否在背包中装入总价值不小于 $K$，总重量不超过 $B$ 的物品吗？

**即：是否存在子集 $T \subseteq \{1, 2, ..., n\}$，使得：**

$$\sum_{i \in T} v_i \ge K \quad \text{并且} \quad \sum_{i \in T} w_i \le B$$

任意猜想一个子集 $T$ 并在多项式时间内验证上式，都成立则回答 “Yes”，否则回答 “No”


# 多项式时间规约

- **$Π$ (Pi):** 代表一个**判定问题** (Decision Problem)。
    - $Π1$​ 是原问题（比如：3-SAT 问题）。
    - $Π2$​ 是目标问题（比如：独立集问题）。
- **$D$ (Domain):** 代表问题的**输入实例全集**。
    - $D1$​: 问题 $Π1​$ 的所有可能输入（比如：所有的逻辑公式）。
    - $D2$​: 问题 $Π2$​ 的所有可能输入（比如：所有的图）。
- **Y (Yes-instances):** 代表问题的“真”实例集合。
    - 因为是判定问题，答案只有 Yes/No。
    - $Y_1$​: 在 $D1​$ 中，那些答案为 Yes 的输入集合（比如：所有**能**被满足的逻辑公式）。
- **I (Instance):** 代表 $D$ 中的某一个具体输入实例。

- 如果存在一个函数$f:D1​→D2$ 
- $f$ 是多项式时间可计算的
- 对所有的 $I∈D1​, I∈Y1​⟺f(I)∈Y2​$
- 则
$$\Pi_1≤_p \Pi_2$$

- **核心思想：** 归约（Reduction）不仅仅是“简化”，它的本质是**问题的转化**。 我们记作：
$$
A≤_p​B
$$
读作：“问题 A 可以（在多项式时间内）归约为问题 B”。
- **物理含义**：问题 $Π_2​$ 的难度 **≥** 问题 $Π_1$​ 的难度。
- 多项式时间规约具有**传递性**

-  **能多项式时间变换到P类问题都是P类问题** $\Pi_1 \le_p \Pi_2$ ， $\Pi_2 \in P \Rightarrow \Pi_1 \in P$
-  **难解问题能多项式时间变换到的都是难解问题** 设 $\Pi_1 \le_p \Pi_2$ ， $\Pi_1$是难解的， 则 $\Pi_2$也是难解的

例如：
- 因为 “最大生成树 $\le_p$ 最小生成树”， 则最小生成树 $\in P \Rightarrow$ 最大生成树 $\in P$
- 因为 “HC $\le_p$ TSP”， 则HC是难解的 $\Rightarrow$ TSP也是难解的

# NP完全

## NP-Hard

- 如果对于 $\forall \Pi' \in NP$， $\Pi' \le_p \Pi$， 则称 $\Pi$ 是NP难的（NP-Hard）

## NP-Complete

- 如果 $\Pi$ 是NP难的， 且 $\Pi \in NP$， 则称 $\Pi$ 是NP完全的(或称NPC)。

- NP完全的问题就是NP中最难的问题。
- 如果存在NP难的问题 $\Pi \in P$， 则 P=NP

## 常见NPC问题
#### **布尔可满足性问题 (SAT / 3-SAT)**

- **问题描述：** 给你一个包含 n 个布尔变量（True/False）的复杂逻辑公式，问：是否存在一组赋值，让整个公式的结果为 **True**？

#### **旅行商问题 (Traveling Salesperson Problem, TSP)**

- **注意：** NPC 版本是“判定版本”。
- **问题描述：** 给定一群城市和城市间的距离，问：是否存在一条路线，经过每个城市恰好一次并回到起点，且总路程 **小于 K**？

#### **最大团问题 (Maximum Clique)**

- **问题描述：** 在一个社交网络图中，找出一个最大的子图，使得子图中**任意两个人**都互为好友。

#### **顶点覆盖问题 (Vertex Cover)**

- **问题描述：** 给定一个图，问能不能选出 k 个点，使得图中**每一条边**都至少连接到这 k 个点中的一个？

#### **图着色问题 (Graph Coloring / k-Coloring)**

- **问题描述：** 给定一个地图（或图），能不能用 k 种颜色给每个区域染色，让相邻的区域颜色不同？

## 如何证明问题是NP完全的

> 定理： 如果存在NP难的问题 $\Pi'$， 使得 $\Pi' \le_p \Pi$， 则 $\Pi$ 是NP难的。

> 推论： 如果 $\Pi \in NP$， 并且存在在NP完全的问题 $\Pi'$， 使得 $\Pi' \le_p \Pi$， 则 $\Pi$ 是NP完全的。

> 证明 $\Pi$ 是NP完全的一般步骤：

* 1.证明 $\Pi \in NP$；
* 2.找一个已知的NP完全的问题 $\Pi'$， 证明 $\Pi' \le_p \Pi$

