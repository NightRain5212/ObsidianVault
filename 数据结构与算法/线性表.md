
- 线性结构是最简单的结构，元素之间只有前驱和后继关系。

- 对于非空的线性表，其特点： 
	- （1）存在唯一的一个被称作“第一个”的数据元素； 
	- （2）存在唯一的一个被称作“最后一个”的数据元素； 
	- （3）除第一个之外，结构中的每个数据元素均只有一个直接前驱； 
	- （4）除最后一个之外，结构中的每个数据元素均只有一个直接后继
- 关键字：线性表中的结点可由若干个字段组成，我们称能**唯一标识结点的 段为关键字**，或简称为键。


## 数组

- 线性表的**顺序存储**：用一组连续的存储单元依次存储线性表中的结点。
- 顺序存储：可以直接计算出$k_i$的开始地址。随机访问十分方便。
- 它是相同类型的元素序列，在物理上连续。
- 数组的插入
	- 在数组中插入元素涉及到元素的移动。（注意移动的先后顺序）
	- 将插入到的位置开始的一直到最后的所有元素向后移动一位
- 数组的删除 
	- 删除元素也需要移动。（注意移动的先后顺序）
	- 将删除后的数组中删除位置后面的全部元素向前移动一位。
- 数组反转 
	- 数组的最后一个例子是反转，即把所有元素反过来储存。
	- 交换操作主要有两种实现方法。一是用辅助变量，二是使用异或运算符。
	- 异或运算符的使用
```
//异或运算符交换变量
a = a ^ b;
b = a ^ b;
a = a ^ b;
```
- 特点：
	- 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，我们可以认为，线性表的逻辑结构与存储结构一 致。 
	- 在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。
	- 可以粗略地认为，访问每个元素所花时间相等。 这种存取元素的方法被称为**随机存取**
- 缺点： 
	- （1）插入或删除一个结点平均需要移动一半左右的结点，效率低。
	- （2）线性表的容量扩充不太方便。


## 链表

- 一般来说，我们习惯把链接关系`next`和数据`a`分离的，不需要修改`a`只需要修改`next`。
- 链表的关键是链接关系，必须定义清楚，并且维持下去。链接关系的维护是最容易出错的。

- 线性链表的每个**结点**: **数据域 + 指针域**
	- 指针域存储直接后继存储位置(地址)的域
	- 数据域存储数据元素信息的域

### 单向链表

- 如果定义了“第1个元素”位置first，那么当往链表的第一个位置之前再插入一个元素时，一定要修改这个first。通常我们不愿意单独处理这样的特殊情况，而设置一个虚拟元素，把它作为“第0个元素”，它始终是`a[0]`。这样，不管遇到什么样的情况， 改变的都是某个元素的链接域，不需要单独处理first元素。

- 只需用两个数组即可。`int a[]`表示元素数据，而`int next[]`表示每个元素的后继元素
```cpp
#define MAXN 1000
struct LinkedList{
	int a[MAXN];
	int next[MAXN];
};

// 或
struct Node{
	int val;
	Node* next;
};
struct LList {
	Node* head;
	int size;
};
```
- next为0的元素是最后一个元素。插入和删除过程只需要修改链接关系。
- 需要特别注意的是：在删除的时候，结点q仍然是存在的，而且“下一个元素”仍然是r。只不过从链表开头遍历时永远都到不了结点q。在这个意义下，结点q 确实已经从链表中删除了。

- **带表头结点的单链表**：为了处理方便，经常在单链表的第一个结点之前附加一个结点，称为表头结点（也简称头结点），这个结点不存放线性表的数据。
- **表头结点**: 数据域可以不存储任何信息，也可存储与数据元素类型相同的其他 附加信息。例如，当数据元素为整数型时，头结点的数据域中可以存放线性 表的长度
- 链表增加表头结点的作用： 
	- 便于首元结点的处理 
	- 便于空表和非空表的统一处理
- **单链表的访问**：非随机存取。访问时只能通过头指针进入链表，并通过每个结点的指针域向后扫描其余 结点，访问第一个结点和最后一个结点所花费的时间不等。要访问第i个数据元素，**必须从头指针出发，一个一个向后访问**。即**顺序存取法**。


### 双向链表

- 除了“下一元素指针”next外，再设置 “上一元素指针”prev。
- 和单向链表类似，删除结点q时，并 不需要故意破坏它的前向和后向指针。
- 链表的插入与删除
![[链表的插入与删除.png]]
 - 为了方便，我们再规定`next[0]`表示第一个元素，`prev[0]`表示最后一个元素，这样 的效果就是：好比由虚拟元素0连接起来的环状链表一样。事实上，这种表示方法 确实很容易转化为循环链表：当发现`next[x]=0`时继续读`next[0]`，发现`prev[x]=0`时继续 读`prev[0`]。而对于普通的双向链表，到达元素0意味着遍历结束。


## 栈

- 栈的实现 
	- 栈只能在一头进行操作，相对比较容易实现。用一个数组int stack[]和栈 顶指针top即可，插入和删除（也称push和pop）
	- 出栈时并不需要让`stack[top]`变为0。由于top已经减1了，在逻辑 上原来的栈顶元素已经不在栈中，虽然在物理上这个元素本身没有一点变化。

## 队列

- 队列的实现 
	- 队列的实现需要更多的技巧，原因在于操作是在两端进行的。 删除总是从队首端进行，称为出队(dequeue) ，插入总是在队尾端进行，称为入 队(enqueue) 。
- 删除操作
	- 在删除队首时移动元素，始终保持队首是第一个元素。这种操作引起大量元素移动，到队列元素多时非常慢。
	- 第二种方法不修改数组本身，而修改队首指针。第一个元素仍然是1，但它不再是队首，队首变成了第二个元素。
- 考虑一个空队列不断执 行enqueue,dequeue,enqueue,dequeue · · ·的操作，first将变得很大（意味着需要一个很大的数组，否则`queue[first]` 将产生下标越界），但队列里其实什么都没有！这显然是对空间的浪费。
- 解决的方法是使用循环队列，把数组看成是环状的。

