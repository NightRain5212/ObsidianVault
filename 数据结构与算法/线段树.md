- å‚è€ƒï¼š[çº¿æ®µæ ‘åŸºç¡€ - OI Wiki](https://oi-wiki.org/ds/seg/)

- çº¿æ®µæ ‘å¯ä»¥åœ¨Â $ğ‘‚(logâ¡ğ‘)$ çš„æ—¶é—´å¤æ‚åº¦å†…å®ç°å•ç‚¹ä¿®æ”¹ã€åŒºé—´ä¿®æ”¹ã€åŒºé—´æŸ¥è¯¢ï¼ˆåŒºé—´æ±‚å’Œï¼Œæ±‚åŒºé—´æœ€å¤§å€¼ï¼Œæ±‚åŒºé—´æœ€å°å€¼ï¼‰ç­‰æ“ä½œã€‚
- æ˜¯å¸¸ç”¨çš„ç»´æŠ¤åŒºé—´ä¿¡æ¯çš„æ•°æ®ç»“æ„ã€‚

# å»ºæ ‘

- çº¿æ®µæ ‘å°†æ¯ä¸ªé•¿åº¦ä¸ä¸ºÂ 1![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "1")Â çš„åŒºé—´åˆ’åˆ†æˆå·¦å³ä¸¤ä¸ªåŒºé—´é€’å½’æ±‚è§£ï¼ŒæŠŠæ•´ä¸ªçº¿æ®µåˆ’åˆ†ä¸ºä¸€ä¸ªæ ‘å½¢ç»“æ„ï¼Œé€šè¿‡åˆå¹¶å·¦å³ä¸¤åŒºé—´ä¿¡æ¯æ¥æ±‚å¾—è¯¥åŒºé—´çš„ä¿¡æ¯ã€‚

```cpp
// ä»int a[N]æ•°ç»„ä¸­æ„å»ºå½“å‰èŠ‚ç‚¹ç¼–å·ä¸ºpï¼Œç®¡è¾–åŒºé—´ä¸º[l,r]çš„èŠ‚ç‚¹
void _build(int s, int t, int p, ll a[]) {
	// å½“åŒºé—´çš„å·¦å³ç«¯ç‚¹é‡åˆæ—¶ï¼Œç›´æ¥æ›´æ–°è¯¥ç‚¹å³å¯
	if (s == t) {
		d[p] = a[s];
		return;
	}
	// å°†åŒºé—´åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†[s,mid],[mid+1,t],åˆ†åˆ«æ›´æ–°åæ›´æ–°[s,t]åŒºé—´
	int m = ((t - s) >> 1) + s;
	// åŒºé—´[s,mid]å¯¹åº”èŠ‚ç‚¹ä¸º2*p
	_build(s, m, 2 * p, a);
	// åŒºé—´[mid+1,t]å¯¹åº”èŠ‚ç‚¹ä¸º2*p+1
	_build(m + 1, t, 2 * p + 1, a);
	// æœ€åæ›´æ–°[s,t]åŒºé—´
	d[p] = d[2 * p] + d[2 * p + 1];
}
```

# åŒºé—´æ›´æ–°

- å½“è¦æ±‚æ›´æ–°åŒºé—´$[l,r]$ä¸­çš„æ‰€æœ‰æ•°æ—¶ï¼Œä¸€ä¸ªä¸ªéå†æ›´æ–°æ˜¯ååˆ†ä½æ•ˆçš„ã€‚
- å¼•å…¥ä¸€ä¸ª**æ‡’æƒ°æ ‡è®°**ï¼Œé€šè¿‡å»¶è¿Ÿå¯¹èŠ‚ç‚¹ä¿¡æ¯çš„æ›´æ”¹ï¼Œä»è€Œå‡å°‘å¯èƒ½ä¸å¿…è¦çš„æ“ä½œæ¬¡æ•°ã€‚
- æ›´æ–°ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œé€šè¿‡æ‰“æ ‡è®°çš„æ–¹æ³•è¡¨æ˜è¯¥èŠ‚ç‚¹å¯¹åº”çš„åŒºé—´åœ¨æŸä¸€æ¬¡æ“ä½œä¸­è¢«æ›´æ”¹ï¼Œ**ä½†ä¸æ›´æ–°è¯¥èŠ‚ç‚¹çš„å­èŠ‚ç‚¹çš„ä¿¡æ¯**ã€‚
- å®è´¨æ€§çš„ä¿®æ”¹åˆ™åœ¨**ä¸‹ä¸€æ¬¡è®¿é—®å¸¦æœ‰æ ‡è®°çš„èŠ‚ç‚¹æ—¶**æ‰è¿›è¡Œã€‚

```cpp
// å°è£…ä¸‹æ¨æ‡’æ ‡è®°çš„å‡½æ•°ï¼Œå°†ç®¡è¾–åŒºé—´ä¸º[s,t]çš„èŠ‚ç‚¹pçš„æ‡’æ ‡è®°ä¸‹æ¨
void push(int s, int t, int p) {
	// å°†åŒºé—´åˆ’åˆ†ä¸º[s,m],[m+1,t]
	int m = ((t - s) >> 1) + s;
	// å¦‚æœå­˜åœ¨æ‡’æ ‡è®°ï¼Œä¸”ä¸ä¸ºå¶å­èŠ‚ç‚¹åˆ™ä¸‹æ¨æ‡’æ ‡è®°
	if (lazy[p] && s != t) {
		// æ›´æ–°ä¸¤ä¸ªå­©å­èŠ‚ç‚¹
		d[2 * p] += (m - s + 1) * lazy[p];
		d[2 * p + 1] += (t - m) * lazy[p];
		// æ›´æ–°ä¸¤ä¸ªå­©å­èŠ‚ç‚¹çš„æ‡’æ ‡è®°
		lazy[2 * p] += lazy[p];
		lazy[2 * p + 1] += lazy[p];
		// æ¸…ç©ºå½“å‰èŠ‚ç‚¹æ‡’æ ‡è®°
		lazy[p] = 0;
	}
}

// å°†åŒºé—´[l,r]çš„æ•°éƒ½åŠ ä¸Šc; pæ˜¯å½“å‰èŠ‚ç‚¹ç¼–å·ï¼Œç®¡è¾–åŒºé—´[s,t]
void _update(int l, int r, ll c, int s, int t, int p) {
	// å¦‚æœ[s,t]æ˜¯[l,r]çš„å­é›†ï¼Œåˆ™ç›´æ¥æ›´æ–°å¹¶å¸¦ä¸Šæ‡’æ ‡è®°ã€‚
	if (l <= s && t <= r) {
		d[p] += (t - s + 1) * c;
		lazy[p] += c;
		return;
	}
	// å¦åˆ™è€ƒè™‘ä¸¤ä¸ªå­åŒºé—´[s,m],[m+1,t]
	int m = ((t - s) >> 1) + s;
	// è®¿é—®äº†èŠ‚ç‚¹pï¼Œä¸‹æ¨æ‡’æ ‡è®°ï¼Œæ›´æ–°å­èŠ‚ç‚¹
	push(s, t, p);
	// å¦‚æœ[l,r]ä¸[s,m]æœ‰äº¤é›†ï¼Œæ›´æ–°å¯¹åº”å­èŠ‚ç‚¹
	if (l <= m) {
		_update(l, r, c, s, m, 2 * p);
	}
	// å¦‚æœ[l,r]ä¸[m+1,t]æœ‰äº¤é›†ï¼Œæ›´æ–°å¯¹åº”å­èŠ‚ç‚¹
	if (r > m) {
		_update(l, r, c, m + 1, t, 2 * p + 1);
	}
	// ä½¿ç”¨æ›´æ–°åçš„å­èŠ‚ç‚¹æ›´æ–°è‡ªèº«ã€‚
	d[p] = d[2 * p] + d[2 * p + 1];
}
```


# åŒºé—´æŸ¥è¯¢

```cpp
// æŸ¥è¯¢åŒºé—´ä¸º[l,r]çš„åŒºé—´å’Œï¼›å½“å‰èŠ‚ç‚¹ç¼–å·ä¸ºpï¼Œç®¡è¾–åŒºé—´[s,t]
ll _query(int l, int r, int s, int t, int p) {
	// å¦‚æœ[s,t]æ˜¯[l,r]çš„å­é›†ï¼Œç›´æ¥è¿”å›ç»“æœ
	if (l <= s && t <= r) {
		return d[p];
	}
	// å¦åˆ™è€ƒè™‘[s,m],[m+1,t]ä¸¤ä¸ªåŒºé—´ã€‚
	int m = ((t - s) >> 1) + s;
	// è®¿é—®äº†èŠ‚ç‚¹pï¼Œä¸‹æ¨æ‡’æ ‡è®°
	push(s, t, p);
	// è®°å½•ç­”æ¡ˆ
	ll ans = 0;
	// å¦‚æœ[s,m]ä¸[l,r]æœ‰äº¤é›†ï¼Œå‘ä¸‹è®¿é—®å­èŠ‚ç‚¹2*p
	if (l <= m) {
		ans = _query(l, r, s, m, 2 * p);
	}
	// å¦‚æœ[m+1,t]ä¸[l,r]æœ‰äº¤é›†ï¼Œå‘ä¸‹è®¿é—®å­èŠ‚ç‚¹2*p+1
	if (r > m) {
		ans += _query(l, r, m + 1, t, 2 * p + 1);
	}
	//è¿”å›ç­”æ¡ˆ
	return ans;
}
```

# å°è£…ç»“æ„(åŒºé—´å’Œï¼ŒåŒºé—´åŠ )

```cpp
struct segTree {
    ll d[4 * N];
    ll lazy[4 * N];
    int n;

    void _build(int s, int t, int p, ll a[]) {
        if (s == t) {
            d[p] = a[s];
            return;
        }
        int m = ((t - s) >> 1) + s;
        _build(s, m, 2 * p, a);
        _build(m + 1, t, 2 * p + 1, a);
        d[p] = d[2 * p] + d[2 * p + 1];
    }

    void push(int s, int t, int p) {
        int m = ((t - s) >> 1) + s;
        if (lazy[p] && s != t) {
            d[2 * p] += (m - s + 1) * lazy[p];
            d[2 * p + 1] += (t - m) * lazy[p];
            lazy[2 * p] += lazy[p];
            lazy[2 * p + 1] += lazy[p];
            lazy[p] = 0;
        }
    }

    void _update(int l, int r, ll c, int s, int t, int p) {
        if (l <= s && t <= r) {
            d[p] += (t - s + 1) * c;
            lazy[p] += c;
            return;
        }

        int m = ((t - s) >> 1) + s;
        push(s, t, p);

        if (l <= m) {
            _update(l, r, c, s, m, 2 * p);
        }
        if (r > m) {
            _update(l, r, c, m + 1, t, 2 * p + 1);
        }
        d[p] = d[2 * p] + d[2 * p + 1];
    }

    ll _query(int l, int r, int s, int t, int p) {
        if (l <= s && t <= r) {
            return d[p];
        }
        int m = ((t - s) >> 1) + s;
        push(s, t, p);

        ll ans = 0;
        if (l <= m) {
            ans = _query(l, r, s, m, 2 * p);
        }
        if (r > m) {
            ans += _query(l, r, m + 1, t, 2 * p + 1);
        }
        return ans;
    }

    void build(int n, ll a[]) {
        this->n = n;
        memset(lazy, 0, sizeof(lazy));
        _build(1, n, 1, a);
    }

    void update(int l, int r, int c) {
        _update(l, r, c, 1, n, 1);
    }

    ll query(int l, int r) {
        return _query(l, r, 1, n, 1);
    }

} tree;
```

# ä¾‹é¢˜

- [P3372 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1 - æ´›è°·](https://www.luogu.com.cn/problem/P3372)
- æ ‡å‡†çš„çº¿æ®µæ ‘æ¨¡æ¿é¢˜
```cpp
#include <bits/stdc++.h>
#define ll long long
#define int long long
#define IOS \
    ios::sync_with_stdio(false); \
    cin.tie(nullptr);
#define endl '\n'
int const inf = 0x3f3f3f3f;
ll const infll = 0x3f3f'3f3f'3f3f'3f3f;
double const PI = acos(-1.0);
using namespace std;
// ifstream fin("input.txt");
// ofstream fout("output.txt");
// #define cin fin
// #define cout fout

int const N = 1e5 + 10;
int n, m;
ll a[N];

struct segTree {
    ll d[4 * N];
    ll lazy[4 * N];
    int n;

    void _build(int s, int t, int p, ll a[]) {
        if (s == t) {
            d[p] = a[s];
            return;
        }
        int m = ((t - s) >> 1) + s;
        _build(s, m, 2 * p, a);
        _build(m + 1, t, 2 * p + 1, a);
        d[p] = d[2 * p] + d[2 * p + 1];
    }

    void push(int s, int t, int p) {
        int m = ((t - s) >> 1) + s;
        if (lazy[p] && s != t) {
            d[2 * p] += (m - s + 1) * lazy[p];
            d[2 * p + 1] += (t - m) * lazy[p];
            lazy[2 * p] += lazy[p];
            lazy[2 * p + 1] += lazy[p];
            lazy[p] = 0;
        }
    }

    void _update(int l, int r, ll c, int s, int t, int p) {
        if (l <= s && t <= r) {
            d[p] += (t - s + 1) * c;
            lazy[p] += c;
            return;
        }

        int m = ((t - s) >> 1) + s;
        push(s, t, p);

        if (l <= m) {
            _update(l, r, c, s, m, 2 * p);
        }
        if (r > m) {
            _update(l, r, c, m + 1, t, 2 * p + 1);
        }
        d[p] = d[2 * p] + d[2 * p + 1];
    }

    ll _query(int l, int r, int s, int t, int p) {
        if (l <= s && t <= r) {
            return d[p];
        }
        int m = ((t - s) >> 1) + s;
        push(s, t, p);

        ll ans = 0;
        if (l <= m) {
            ans = _query(l, r, s, m, 2 * p);
        }
        if (r > m) {
            ans += _query(l, r, m + 1, t, 2 * p + 1);
        }
        return ans;
    }

    void build(int n, ll a[]) {
        this->n = n;
        memset(lazy, 0, sizeof(lazy));
        _build(1, n, 1, a);
    }

    void update(int l, int r, int c) {
        _update(l, r, c, 1, n, 1);
    }

    ll query(int l, int r) {
        return _query(l, r, 1, n, 1);
    }

} tree;

signed main() {
    IOS cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    tree.build(n, a);
    while (m--) {
        int op;
        cin >> op;
        if (op == 1) {
            int x, y;
            ll k;
            cin >> x >> y >> k;
            tree.update(x, y, k);
        } else {
            int x, y;
            cin >> x >> y;
            cout << tree.query(x, y) << endl;
        }
    }

    // fin.close(),fout.close();
    return 0;
}
```


- [P3373 ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 2 - æ´›è°·](https://www.luogu.com.cn/problem/P3373)
- ä½¿ç”¨ä¸¤ä¸ªæ‡’æ ‡è®°æ•°ç»„æ”¯æŒåŠ æ³•ä¸ä¹˜æ³•ï¼Œæ›´æ–°ä¹˜æ³•æ‡’æ ‡è®°æ—¶éœ€è¦æ›´æ–°åŠ æ³•æ‡’æ ‡è®°
```cpp
#include <bits/stdc++.h>
#define ll long long
// #define int long long
#define IOS \
    ios::sync_with_stdio(false); \
    cin.tie(nullptr);
#define endl '\n'
int const inf = 0x3f3f3f3f;
ll const infll = 0x3f3f'3f3f'3f3f'3f3f;
double const PI = acos(-1.0);
using namespace std;
// ifstream fin("input.txt");
// ofstream fout("output.txt");
// #define cin fin
// #define cout fout

int const N = 1e5 + 10;
int n, q, m;
int a[N];

inline int add(int x, int y) {
    return (x + y * 1LL) % m;
}

inline int mul(int x, int y) {
    return (1LL * x * y ) % m;
}

struct segTree {
    int d[4 * N];
    // ä½¿ç”¨å¤šä¸ªæ‡’æ ‡è®°è¿›è¡Œå¤šç§è¿ç®—
    int lazy[4 * N];  // åŠ æ³•æ‡’æ ‡è®°
    int lzmul[4 * N]; // ä¹˜æ³•æ‡’æ ‡è®°
    int n;

    void _build(int s, int t, int p, int a[]) {
        lzmul[p] = 1;
        if (s == t) {
            d[p] = a[s];
            return;
        }
        int mid = ((t - s) >> 1) + s;
        _build(s, mid, 2 * p, a);
        _build(mid + 1, t, 2 * p + 1, a);
        d[p] = add(d[2 * p], d[2 * p + 1]);
    }
	// ä¸‹æ¨æ‡’æƒ°æ ‡è®°
    void pushdown(int s, int t, int p) {
        int mid = ((t - s) >> 1) + s;
        if (lzmul[p] != 1 && s != t) {
            d[2 * p] = mul(d[2 * p], lzmul[p]);
            d[2 * p + 1] = mul(d[2 * p + 1], lzmul[p]);
            lzmul[2 * p] = mul(lzmul[2 * p], lzmul[p]);
            lzmul[2 * p + 1] = mul(lzmul[2 * p + 1], lzmul[p]);
            // æ‡’æ ‡è®°ä¼ é€’
            lazy[2 * p] = mul(lazy[2 * p], lzmul[p]);
            lazy[2 * p + 1] = mul(lazy[2 * p + 1], lzmul[p]);
            lzmul[p] = 1;
        }
        if (lazy[p] && s != t) {
            d[2 * p] = add(d[2 * p], mul((mid - s + 1), lazy[p]));
            d[2 * p + 1] = add(d[2 * p + 1], mul((t - mid), lazy[p]));
            lazy[2 * p] = add(lazy[2 * p], lazy[p]);
            lazy[2 * p + 1] = add(lazy[2 * p + 1], lazy[p]);
            lazy[p] = 0;
        }
    }

    void jia(int l, int r, int c, int s, int t, int p) {
        if (l <= s && t <= r) {
            d[p] = add(d[p], mul(c, (t - s + 1)));
            lazy[p] = add(lazy[p], c);
            return;
        }
        int mid = ((t - s) >> 1) + s;
        pushdown(s, t, p);
        if (l <= mid) {
            jia(l, r, c, s, mid, 2 * p);
        }
        if (r >= mid + 1) {
            jia(l, r, c, mid + 1, t, 2 * p + 1);
        }
        d[p] = add(d[2 * p], d[2 * p + 1]);
    }

    void chen(int l, int r, int c, int s, int t, int p) {
        if (l <= s && t <= r) {
            d[p] = mul(d[p], c);
            lzmul[p] = mul(lzmul[p], c);
            // æ‡’æ ‡è®°ä¼ é€’
            lazy[p] = mul(lazy[p], c);
            return;
        }
        int mid = ((t - s) >> 1) + s;
        pushdown(s, t, p);
        if (l <= mid) {
            chen(l, r, c, s, mid, 2 * p);
        }
        if (r >= mid + 1) {
            chen(l, r, c, mid + 1, t, 2 * p + 1);
        }
        d[p] = add(d[2 * p], d[2 * p + 1]);
    }

    int query(int l, int r, int s, int t, int p) {
        if (l <= s && t <= r) {
            return d[p];
        }
        int mid = ((t - s) >> 1) + s;
        pushdown(s, t, p);
        int ans = 0;
        if (l <= mid) {
            ans = add(ans, query(l, r, s, mid, 2 * p));
        }
        if (r >= mid + 1) {
            ans = add(ans, query(l, r, mid + 1, t, 2 * p + 1));
        }
        return ans;
    }

} tree;

signed main() {
    IOS cin >> n >> q >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    tree.n = n;
    tree._build(1, n, 1, a);
    while (q--) {
        int op;
        cin >> op;
        if (op == 1) {
            int x, y, k;
            cin >> x >> y >> k;
            tree.chen(x, y, k, 1, n, 1);
        } else if (op == 2) {
            int x, y, k;
            cin >> x >> y >> k;
            tree.jia(x, y, k, 1, n, 1);
        } else {
            int x, y;
            cin >> x >> y;
            cout << tree.query(x, y, 1, n, 1) << endl;
        }
    }
    // fin.close(),fout.close();
    return 0;
}
```

# åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘

- å †å¼å‚¨å­˜çš„æƒ…å†µä¸‹ï¼Œéœ€è¦ç»™çº¿æ®µæ ‘å¼€Â $4ğ‘›$Â å¤§å°çš„æ•°ç»„ã€‚ä¸ºäº†èŠ‚çœç©ºé—´ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ä¸€æ¬¡æ€§å»ºå¥½æ ‘ï¼Œè€Œæ˜¯åœ¨æœ€åˆåªå»ºç«‹ä¸€ä¸ªæ ¹ç»“ç‚¹ä»£è¡¨æ•´ä¸ªåŒºé—´ã€‚å½“æˆ‘ä»¬éœ€è¦è®¿é—®æŸä¸ªå­åŒºé—´æ—¶ï¼Œæ‰å»ºç«‹ä»£è¡¨è¿™ä¸ªåŒºé—´çš„å­ç»“ç‚¹ã€‚
- åŠ¨æ€å¼€ç‚¹çº¿æ®µæ ‘çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯ï¼š**ç»“ç‚¹åªæœ‰åœ¨æœ‰éœ€è¦çš„æ—¶å€™æ‰è¢«åˆ›å»º**ã€‚
- è§ [çº¿æ®µæ ‘åŸºç¡€ - OI Wiki](https://oi-wiki.org/ds/seg/#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91)
