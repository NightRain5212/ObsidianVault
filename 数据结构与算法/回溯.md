
## 概念

- 在使用递归进行`DFS`或`BFS`时，经常使用回溯法寻找有效解，其本质是，遇到走不通的情况时，回到上一步的情况，再寻找其他出路。

## 一般过程

- 摘自：[优化 - OI Wiki](https://oi-wiki.org/search/opt/)
```cpp
void dfs(传入数值) 
{ 
	if (到达目的地) 
		ans = 从当前解与已有解中选最优; 
	for (遍历所有可能性) {
		if (可行) { 
			进行操作; 
			dfs(缩小规模); 
			撤回操作; 
		}
	}
}
```

## 例题

### N皇后问题

- 在这个问题中，你需要解决在 $N×N$ 棋盘上放置 $N$ 个皇后的问题，以使皇后们不会互相攻击。使用排列 $(p_1,p_2,…,p_N)$ 表示：皇后 $i$ 放置在数字 $i$ 的行和数字 $p_i$ 的列中。程序接收一个自然数 $N$ ($N≤12$) 。程序应该输出所有必需的排列（每个排列占一行）。
- 样例
```
[input]
4
[output]
(2,4,1,3)
(3,1,4,2)
```
- 示例代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int MAXN = 100;
int N;
// 分别表示对应列，主对角线，副对角线是否已被占领；
// 主对角线上：行数+列数=定值
// 副对角线上：行数-列数=定值
bool col[MAXN],zhu[MAXN],ci[MAXN]; 

vector<int> ans;
// i为当前行数
void dfs(int i)
{
	// 到达搜索终点
    if(i==N+1) {
	    // 输出答案
        cout<<"(";
        for(int i=0;i<ans.size();i++) {
            cout<<ans[i]<<(i==ans.size()-1?")":",");
        }
        cout<<"\n";
        return;
    }

	// j：1->N 遍历可能放在的列数
    for(int j=1;j<=N;j++) {
        if(!col[j] && !zhu[i+j] && !ci[i-j+N]){
	        // 标记位置已被占领
            col[j] = 1;
            zhu[i+j] = 1;
            ci[i-j+N] = 1;
            ans.push_back(j);
            // 搜索下一行
            dfs(i+1); 
            // 回溯，还原现场
            ans.pop_back();
            col[j] = 0;
            zhu[i+j] = 0;
            ci[i-j+N] = 0;
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>N;
    dfs(1);
    return 0;
}

```

### 称重问题

- 有一台双盘秤和一组砝码。将一个重 $K$ 克的称量物体放在秤的左盘上。秤能平衡吗？如果能，请确定每个秤盘上需要放置哪些砝码。（每个砝码只有一份，有些砝码可以不用）
- 首先输入左侧托盘上放置物品的重量 $K$ （ $1≤K≤50$ ），然后输入砝码的总数 $N$ （$1≤N≤10$ ） ；接下来输入 $N$ 个不超过 $50$ 的不同自然数，分别表示砝码的重量。
- 第一行输出需要放在秤盘左侧的砝码的重量；第二行输出需要放在秤盘右侧的砝码的重量。如果某个秤盘上不需要放置砝码，则输出数字 $0$。如果使用给定的砝码无法使秤平衡，则输出数字 $-1$。如果有多个选项，则输出其中任意一个。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int K,N;
int w[12];

bool ok=false;
vector<int> ansleft;
vector<int> ansright;

// index为当前考虑第index个砝码，left表示当前左盘重量，right表示当前右盘重量
void solve(int index,int left,int right)
{
	 // 到达搜索终点
    if(index == N+1) {
	    // 如果找到答案则输出答案(仅一次)
        if(left + K == right && !ok) {
            ok=true;
            if(ansleft.empty()) cout<<0<<"\n";
            else {
                for(int i:ansleft) cout<<i<<" ";
                cout<<'\n';
            }
            if(ansright.empty()) cout<<0<<"\n";
            else {
                for(int i:ansright) cout<<i<<" ";
                cout<<'\n';
            }
        }
        return;
    }

	// 不选择当前砝码的情况
    solve(index+1,left,right);

	// 将当前砝码放在右盘的情况
    ansright.push_back(w[index]);
    solve(index+1,left,right+w[index]);
    ansright.pop_back(); // 回溯还原现场

	// 将当前砝码放在左盘的情况
    ansleft.push_back(w[index]);
    solve(index+1,left+w[index],right);
    ansleft.pop_back(); // 回溯还原现场
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>K>>N;
    for(int i=1;i<=N;i++) cin>>w[i];
    solve(1,0,0);
    // 没找到答案
    if(!ok) {
        cout<<-1;
    }
    return 0;
}

```

