
# 二分图

- 二分图又称作二部图，是图论中的一种特殊模型。 
- 设 $G=(V,E)$ 是一个无向图，如果顶点 $V$ 可分割为两个互不相交的子集 $(A,B)$，并且图中的每条边$(i，j)$所关联的两个顶点 $i$ 和 $j$ 分别属于这两个不同的顶点集 $i \in A,j \in B$，则称图$G$为一个二分图。

# 匈牙利算法

## 交错路

- 交错路：M是图G的一个匹配，设p是图G的一条路径，如果p的任意两条相邻的边一定是一条属于M而另一条不属于M,则称？是一条交错链。如果p只含一条边，那么无论该边是否属于M,则 p一定是一条交错链。


```cpp
#include <bits/stdc++.h>
#define ll long long
//#define int long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);
#define endl '\n' 
const int inf = 0x3f3f3f3f;
const ll infll = 0x3f3f3f3f3f3f3f3f;
const double PI = acos(-1.0);
using namespace std;
//ifstream fin("input.txt");
//ofstream fout("output.txt");
//#define cin fin
//#define cout fout
const int M = 5e4+5;
const int N = 510;

struct Edge {
    int to,next;
} edges[M];

int head[N];
int sz;
int n,m,e;
int ans;

bool vis[N];
int match[N];

void addedge(int from ,int to) {
    edges[++sz].to = to;
    edges[sz].next = head[from];
    head[from] = sz;
}

// 返回是否存在增广路
bool find(int from) {
    // 遍历该左节点的所有出边
    for(int i=head[from];i!=-1;i=edges[i].next) {
        int to = edges[i].to;
        // 如果还没访问过
        if(!vis[to]) {
            vis[to] = 1;
            // 1. 目标右节点尚未匹配
            // 2. 右节点已经被匹配但是存在增广路
            if(!match[to] || find(match[to]))
            {
                match[to] = from;
                return true; 
            }
        }
    }
    return false;
}


void solve() {
    for(int i=1;i<=n;i++) {
        memset(vis,0,sizeof(vis));
        if(find(i)) {
            // 找到增广路
            ans++;
        }
    }
}


signed main()
{
    IOS
    memset(head,-1,sizeof(head));   
    cin>>n>>m>>e;
    while(e--)
    {
        int u,v;cin>>u>>v;
        addedge(u,v);
    }
    solve();
    cout<<ans;


    //fin.close(),fout.close();
    return 0;
}

```