
# 二分图

- 二分图又称作二部图，是图论中的一种特殊模型。 
- 设 $G=(V,E)$ 是一个无向图，如果顶点 $V$ 可分割为两个互不相交的子集 $(A,B)$，并且图中的每条边$(i，j)$所关联的两个顶点 $i$ 和 $j$ 分别属于这两个不同的顶点集 $i \in A,j \in B$，则称图$G$为一个二分图。

# 匈牙利算法

## 增广路

- **匹配边**：即出现在当前匹配集的边。
- **交错路**：即**匹配边和非匹配边交错相邻的路径**。
- **增广路**：**起点和终点都是非匹配点的交错路**。
- 增广路的性质：
	- 增广路上**非匹配边边数比匹配边边数多一**。
	- 增广路边的数量一定为奇数。
	- **将增广路上的匹配边和非匹配边反转，仍是交错路**，并且匹配边的数目增加了1。
	- 增广相当于匹配集合与增广路集合取对称差。

## Berge引理

对于图 $G=(V,E)$ 和它的一个匹配 $M$，匹配 $M$ 是最大匹配，**当且仅当不存在相对于匹配 $M$ 的增广路**．

## 算法思路

- 枚举所有未匹配点，找增广路径，直到找不到增广路径．

```cpp
// 返回是否存在增广路
bool find(int from) {
    // 遍历该左节点的所有出边
    for(int i=head[from];i!=-1;i=edges[i].next) {
        int to = edges[i].to;
        // 如果还没访问过
        if(!vis[to]) {
            vis[to] = 1;
            // 1. 目标右节点尚未匹配
            // 2. 右节点已经被匹配但是存在增广路
            if(!match[to] || find(match[to]))
            {
                match[to] = from;
                return true; 
            }
        }
    }
    return false;
}
```

## 实现

- [P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)
- 使用了**链式前向星**来存储边
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define int long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);
#define endl '\n' 
const int inf = 0x3f3f3f3f;
const ll infll = 0x3f3f3f3f3f3f3f3f;
const double PI = acos(-1.0);
using namespace std;
//ifstream fin("input.txt");
//ofstream fout("output.txt");
//#define cin fin
//#define cout fout
const int M = 5e4+5;
const int N = 510;

struct Edge {
    int to,next;
} edges[M];

int head[N];
int sz;

int n,m,e;
int ans;

bool vis[N];
int match[N];

void addedge(int from ,int to) {
    edges[++sz].to = to;
    edges[sz].next = head[from];
    head[from] = sz;
}

// 返回是否存在增广路
bool find(int from) {
    // 遍历该左节点的所有出边
    for(int i=head[from];i!=-1;i=edges[i].next) {
        int to = edges[i].to;
        // 如果还没访问过
        if(!vis[to]) {
            vis[to] = 1;
            // 1. 目标右节点尚未匹配
            // 2. 右节点已经被匹配但是存在增广路
            if(!match[to] || find(match[to]))
            {
                match[to] = from;
                return true; 
            }
        }
    }
    return false;
}


void solve() {
    for(int i=1;i<=n;i++) {
        memset(vis,0,sizeof(vis));
        if(find(i)) {
            // 找到增广路
            ans++;
        }
    }
}


signed main()
{
    IOS
    memset(head,-1,sizeof(head));   
    cin>>n>>m>>e;
    while(e--)
    {
        int u,v;cin>>u>>v;
        addedge(u,v);
    }
    solve();
    cout<<ans;
    //fin.close(),fout.close();
    return 0;
}

```

# 规约为最大流问题

- 建立**超级源点S**。连接S到每一个左部点，容量设为1
- 将原图中存在的每一条边变成从左部点指向右部点的有向边，容量设为1.
- 建立**超级汇点T**。连接每一个右部点到T，容量设为1.
- 这样得到的有向图中的每个网络流，都和二分图中的一组匹配一一对应，且网络**流的容量就是相应的匹配的大小**．
- 因此，求解二分图最大匹配，就相当于**求解相应的有向图中的最大流**．
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define ll long long
#define pii pair<int,int>
#define pll pair<long long, long long>

const int N = 510, M = 6e4+5;
struct Edge {
    int to,next,c;
}edges[M<<1];

int head[N*2];
int sz;

void add_edge(int from, int to, int c) {
    edges[sz].to = to;
    edges[sz].c = c;
    edges[sz].next = head[from];
    head[from] = sz;
    sz++;
}

int n,m,e;
bool vis[N*2];
int incf[N*2];
int mf;
int pre[N*2];

int s,t;

bool bfs() {
    queue<int> q;
    q.push(s);
    memset(vis,0,sizeof(vis));
    incf[s] = 0x3f3f3f3f;
    vis[s]=1;

    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i=head[u];i!=-1;i=edges[i].next) {
            if(edges[i].c) {
                int v = edges[i].to;
                if(vis[v]) continue;
                vis[v]=1;
                incf[v] = min(incf[u],edges[i].c);
                pre[v]=i;
                if(v==t) return 1;
                q.push(v);
            }
        }
    }
    return 0;
}

void ek() {
    while(bfs()) {
        int p =t;
        while(p!=s) {
            int i = pre[p];
            edges[i].c -= incf[t];
            edges[i^1].c += incf[t];
            p = edges[i^1].to;
        }
        mf += incf[t];
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m>>e;
    memset(head,-1,sizeof(head));
    t = n+m+1;
    while(e--) {
        int u,v;cin>>u>>v;
        add_edge(u,n+v,1);
        add_edge(n+v,u,0);
    }
    for(int i=1;i<=n;i++) {
        add_edge(s,i,1);
        add_edge(i,s,0);
    }
    for(int i=1;i<=m;i++) {
        add_edge(i+n,t,1);
        add_edge(t,i+n,0);
    }
    ek();
    cout<<mf;
    return 0;
}
```
