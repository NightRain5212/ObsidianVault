
## 定义
- 从二叉堆的结构说起，它是一棵二叉树，并且是完全二叉树，每个结点中存有一个元素（或者说，有个权值）。

- 堆性质：父亲的权值不小于儿子的权值（大根堆）。同样的，我们可以定义小根堆（父亲的权值不大于儿子的权值）。

- 由堆性质，树根存的是最大/小值。

## 维护（以大根堆为例子）

### 上浮操作

- 将一个节点的值与其父节点的值比较，若该节点的值较大，则交换两者的值。直到不满足条件或已经到根节点。

### 下沉操作

- 在该节点的两个孩子中选中最大的那个孩子交换，然后对交换后的那个子节点进行重复操作，直到底层。

```cpp
// 下沉操作
void down(int x)
{
    while(2*x <= sz)
    {
        int t=2*x;
        if(t+1<=sz && h[t]>h[t+1]) t++;
        if(h[x]<=h[t]) break;
        swap(h[x],h[t]);
        x=t;
    }
}

// 上浮操作
void up(int x)
{
    while(x>1 && h[x] < h[x/2]) {
        swap(h[x],h[x/2]);
        x/=2;
    }
}
```

## 插入

- 直接从最后一个元素后面的位置插入新元素，再向上调整即可。

## 删除（删除堆中最大/小的元素，即删除根结点）

- 将根节点元素与最后一个元素交换后，对新的根节点向下调整即可。
## 建堆

- 从叶子开始，逐个向下调整。复杂度：$O(n)$
```cpp
void buildheap() {
	for(int i=n;i>=1;i--) {
		down(i);
	}
}
```

## 模板

- [P3378 【模板】堆 - 洛谷](https://www.luogu.com.cn/problem/P3378)

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 1e6+5;
int n;
int sz=0;

int h[N];

// 下沉操作
void down(int x)
{
    while(2*x <= sz)
    {
        int t=2*x;
        if(t+1<=sz && h[t]>h[t+1]) t++;
        if(h[x]<=h[t]) break;
        swap(h[x],h[t]);
        x=t;
    }
}

// 上浮操作
void up(int x)
{
    while(x>1 && h[x] < h[x/2]) {
        swap(h[x],h[x/2]);
        x/=2;
    }
}

// 删除
void pop() {
    swap(h[1],h[sz]);
    sz--;
    down(1);
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n;
    while(n--) {
        int op;cin>>op;
        if(op == 1) {
            int x;cin>>x;
            h[sz+1] = x;sz++;
            up(sz);
        }
        else if(op == 2) {
            cout<<h[1]<<"\n";
        }else {
            pop();
        }
    }

    return 0;
}
```