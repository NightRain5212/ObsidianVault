
- **差分约束系统** 是一种特殊的 $n$ 元一次不等式组，它包含 $n$个变量 $x_1,x_2,\dots,x_n$ 以及 $m$ 个约束条件.
- 每个约束条件是由两个其中的变量做差构成的，形如 $x_i-x_j\leq c_k$，其中$1 \leq i, j \leq n, i \neq j, 1 \leq k \leq m$ 并且 $c_k$是常数（可以是非负数，也可以是负数）．
- 我们要解决的问题是：求一组解 $x_1=a_1,x_2=a_2,\dots,x_n=a_n$，**使得所有的约束条件得到满足**，否则判断出无解．
- 差分约束的每一个约束都可以变形为 $x_i \le x_j +c_k$ 的形式，这**与最短路径中松弛操作的式子类似**。
- 对于 $x_j - x_i = k$ 等式相当于**同时满足 $\le k$ 和 $\ge k$。**

## 建图

- 我们将每一个变量$x_i$ 看作图上的节点，对于每个约束条件$x_i - x_j \le c_k$ ($x_i \le x_j +c_k$)从 $x_j$ 到 $x_i$ 连一条权重为 $c_k$ 的有向边

## 建超级原点

差分约束系统给出的通常是一组相对关系，且图可能是不连通的。为了能遍历到所有点并给出一个基准值，通常需要引入一个**超级源点**（通常设为 0 号点）。

- **操作**：建立一个虚拟节点 0，从 0 向所有其他节点 $i$ ($1 \dots n$) 连一条边。
- **权重**：通常设为 0（意味着 $x_i - x_0 \le 0 \Rightarrow x_i \le 0$）。
- **确保图的连通性**，且为所有变量提供一个初始的上界约束。

## 求解

建图完成后，使用 **SPFA** 或 **Bellman-Ford** 算法（因为权值可能为负，Dijkstra 不能用）从超级源点出发求解最短路。
若图中**存在负环，则给定的差分约束系统无解**，否则， $x_i=dist[i]$ 为该差分约束系统的一组解．

- [P5960 【模板】差分约束 - 洛谷](https://www.luogu.com.cn/problem/P5960)
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define int long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);
#define endl '\n' 
#define pii pair<int,int>
const int inf = 0x3f3f3f3f;
const ll infll = 0x3f3f3f3f3f3f3f3f;
const double PI = acos(-1.0);
using namespace std;
//ifstream fin("input.txt");
//ofstream fout("output.txt");
//#define cin fin
//#define cout fout

const int N = 5e3+5;
int m,n;
vector<pii> g[N];

int dist[N],vis[N],cnt[N];


bool spfa(int s) {
    memset(dist , 0x3f , sizeof(dist));
    memset(vis , 0, sizeof(vis));
    memset(cnt , 0, sizeof(cnt));
    dist[s] = 0 , vis[s] = 1;
    queue<int> q;
    q.push(s);
    while(!q.empty()) {
        int u =q.front(); q.pop();
        vis[u]=0;
        for(auto [v,w]:g[u]) {
            if(dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                cnt[v] = cnt[u] + 1;
                if(cnt[v] > n) return 0;
                if(!vis[v]) q.push(v),vis[v]=1;
            }
        }
    }
    return 1;
}

signed main()
{
    IOS
    cin>>n>>m;
    while(m--) {
        int a,b,y;cin>>a>>b>>y;
        g[b].push_back({a,y});
    }
    for(int i=1;i<=n;i++) {
        g[0].push_back({i,0});
    }
    bool ok = spfa(0);
    if(!ok) {
        cout<<"NO";
        return 0;
    }
    for(int i=1;i<=n;i++) cout<<dist[i]<<" ";

    //fin.close(),fout.close();
    return 0;
}
```

