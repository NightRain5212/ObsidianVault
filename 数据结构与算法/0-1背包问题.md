
# 最大化总价值0-1背包

有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_i$ 和价值 $v_i$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

由于**每个物体只有两种可能的状态**（取与不取），对应二进制中的 0 和 1，这类问题便被称为「0-1 背包问题」。

## 题解

- 设状态 $dp[i,j]$ 为拿走前 $i$ 个物品，使用容量为 $j$ 时的最大总价值
- 考虑第 $i$ 个物品的选择策略，分解子问题，
- 若不选第 $i$ 个物品 $dp[i,j]=dp[i-1,j]$
- 若选择第 $i$ 个物品 $dp[i,j] = dp[i-1,j-w_i]+v_i$
- 所以得出状态转移方程
$$dp[i,j]=\max{\{dp[i-1,j],dp[i-1,j-w_i]+v_i\}}$$
- 时间复杂度 $O(Wn)$，空间复杂度$O(Wn)$
```cpp
void solve() {
	for(int i=1;i<=n;i++) {
		for(int j=w[i];j<=W;j++) {
			dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);
		}
	}
}
```

## 滚动数组优化

注意到 $dp[i,j]$ 的来源状态均在$dp[i-1]$中，所以考虑去掉第一维，$dp[i]$表示容量为$i$时的物品总价值。这样每次更新完一层后的$dp[i]$数组中的值就是更新下一层所需的值。

**压维后的状态转移方程**
$$dp[i] = \max{\{dp[i],dp[i-w_i]+v_i\}}$$

注意：更新$dp[i,j]=dp[i-1,j-w[i]]+v[i]$时，这里的$dp[i-1,j-w[i]]$ 是上一层的值，**要注意更新顺序，因此使用滚动数组时从后面往前面更新。**

```cpp
void solve() {
	for(int i=1;i<=n;i++) {
		// 注意更新顺序
		for(int j=W;j>=w[i];j--) {
			dp[i] = max(dp[i],dp[i-w[i]]+v[i]);
		}
	}
}
```
- 空间复杂度$O(n)$
