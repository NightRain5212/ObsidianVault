
- 动态规划是一种通过将一个复杂问题**分解为若干个更小的、重叠的子问题**，并**存储这些子问题的解**，从而避免重复计算，最终找到原问题最优解的算法思想。

## 动态规划问题的三个关键性质

### 最优子结构

- 这是指一个**大问题的最优解**可以由其**子问题的最优解**有效地构造出来。

### 重叠子问题

- 在用递归方式求解时，**很多相同的子问题会被反复计算多次**。

### 无后效性

- 这是指一个子问题的解一旦被确定，就不会再被后续的决策所改变。

## 一般解题流程

### 确定状态

- 你需要定义一个 `dp` 数组（或矩阵），并明确 `dp[i]` 或 `dp[i][j]` 代表什么。
- 一个好的状态定义必须满足“最优子结构”和“无后效性”，并且能够清晰地推导出最终答案。

### 确定状态转移方程

- 这是DP的**灵魂**。状态转移方程是一个数学公式，它描述了**一个状态的解如何由一个或多个比它更小的状态的解推导出来**。

### 初始化

- 这是递推的**起点**。你需要为 `dp` 数组提供一些**边界条件**或**初始值**，使得状态转移方程可以从这些初始值开始正确地进行计算。

### 按一定的顺序遍历递推

- 你需要确定一个计算顺序，来填充整个 `dp` 表格。这个顺序必须保证，在计算任何一个状态 `dp[i]` 时，它所依赖的所有子问题（例如 `dp[i-1]`）都已经计算完毕。

## 方案数问题

### 走楼梯问题

#### EX.1
- 蚱蜢从单元格 1 移动到单元格 n 。一开始，蚱蜢坐在单元格 1 上。它可以向前跳一到两个单元格。求蚱蜢到达单元格 n 的方法数。注意，蚱蜢不能向后跳。
- 状态设置：$dp[i]$ 为蚱蜢到达单元格 $i$ 的方法数
- 状态转移方程：注意到单元格 $i$ 可以从 单元格 $i-1$ 和 $i-2$ 跳到，故
$$dp[i] = dp[i-1] + dp[i-2]$$

#### EX.2

- 蚱蜢正从单元格 1 移动到单元格 n 。一开始，蚱蜢坐在单元格 1 上。它一次跳跃就能从 1 移动到 k 个单元格。求蚱蜢到达单元格 n 的方法数。注意，蚱蜢不能向后跳。
- 状态设置：$dp[i]$ 为蚱蜢到达单元格 $i$ 的方法数
- 状态转移方程：注意到单元格 $i$ 可以从 单元格 $i-1$ , $i-2$ ，... ，$i-k$ 跳到，故
$$dp[i] = \sum_{step =1}^k dp[i-step]$$

#### EX.3

- 在`EX.2`的条件下，新增：在一些单元格里有青蛙，蚱蜢无法在这些单元格中移动。求蚱蜢到达单元格 n 的方法数。假设蚱蜢不能向后跳。
- 状态设置：$dp[i]$ 为蚱蜢到达单元格 $i$ 的方法数
- 状态转移方程：注意到单元格 $i$ 可以从 单元格 $i-1$ , $i-2$ ，... ，$i-k$ （单元格不含青蛙） 跳到。
$$dp[i] = \sum_{step=1}^k dp[i-step] \space \text{if (i-step) no frog} $$
### 01序列问题

#### EX.4

- 需要计算长度为 n 的序列的数量，该序列由 0 和 1 组成，其中没有两个 1 是相邻的。
- 状态设置： $dp[i]$ 为长度为 $i$ 的合法序列数量。
- 状态转移方程：若长度为 $i$ 的合法序列最后一位数字是0，则一共有$dp[i-1]$种可能，若最后一位数字是1，则倒数第二位数字只能为0，则一共有$dp[i-2]$种可能。
$$dp[i] = dp[i-1]+dp[i-2]$$



## 优化问题

### 分配问题

#### EX.5

- 在工厂里，需要将 _N_ 升牛奶倒入瓶子中。有无数个 _K_ 种类型的瓶子，它们的容量各不相同。确定应该使用哪些瓶子，使得所有瓶子都装满，并且瓶子数量最少。
- 状态设置： $dp[i]$ 为装入 $i$ 升牛奶用的最少瓶子数， $c[i]$ 为第 $i$ 种瓶子的容量
- 状态转移方程：装入$i$ 升牛奶 可以由 $i-c[j]$升牛奶用一个$c[j]$的瓶子得到，故
$$dp[i] = \min_{j=1,2...k}(dp[i-c[j]]) + 1$$
