
## 定义

- 图$G$由两个集合组成，分别为顶点集$V$和边集$E$.
$$G=(V,E)$$
- **有向图**：$<v_1,v_2>,<v_2,v_1>$为不同的边，即存在一定方向。
	- $<v_1,v_2>$，$v_1$邻接到$v_2$
	- **入度**：射入顶点的边的条数
	- **出度**：射出顶点的边的条数
	- **完全有向图**：每对顶点都有互相到达的边
	- **强连通**：任意两个节点之间连通
	- **弱连通**：有向图对应的无向图连通
	- **强连通分量**：极大强连通子图
	- **弱连通分量**：极大若连通子图
- **无向图**：$<v_1,v_2>,<v_2,v_1>$不做区分。
	- 记作$(v_1,v_2)$,$v_1,v_2$相邻接。
	- **度**： 无向图中，一个顶点的度就是与其邻接的顶点个数。
	- **完全无向图**：每对顶点都有一条边。
	- **连通**：每个顶点之间都存在路径
	- **连通分量**：图的极大连通子图
- **路径**：
	- 从顶点$v$到顶点$w$,可由一个顶点序列表示，路径长度即为顶点序列个数减一，即边的个数

## 存储结构

### 邻接矩阵


```cpp
int G[N][N];
```
- 共有N个顶点，用二维数组存储边，若存在顶点i到顶点j的边，则`G[i][j]=1`
- 若是带权图，则`G[i][j]=w`
- 若是无向图，则`G[i][j]=G[j][i]`,即对称矩阵

### 邻接表

- 建立二维的线性表，一维存储节点编号，定义为存储该节点的邻接节点。
```cpp
vector<int> G[N];
```
- 带权图
```cpp
struct Node {
	int id;
	int weight;
};
vector<Node> G[N];

//或者
vector<pair<int,int>> G[N];
```

## 图的遍历

 
### 深度优先搜索

- 一条路走到黑，走不通再回头找其他路
```cpp
vector<int> g[N];
bool vis[N];
void dfs(int s) {
	if(vis[s]) return;
	visit(s);
	vis[s]=1;
	for(int u:g[s]) {
		dfs(u);
	}
}
```

### 广度优先搜索

- 呈辐射状从起点扩散
```cpp
vector<int> g[N];
bool vis[N];
void bfs(int s) {
	queue<int> q;
	q.push(s);
	vis[s]=1;
	while(!q.empty()) {
		int cur = q.front();
		q.pop();
		visit(cur);
		for(int u:g[s]) {
			if(vis[u]) continue;
			q.push(u);
			vis[u]=1;
		}
	}
}
```



## 判断图是否为树的条件

一个无向图是树，当且仅当它同时满足以下两个条件：

1. **图是连通的（Connected）**：图中任意两个节点之间都存在至少一条路径。   
2. **图中不包含环（Acyclic）**：从任意节点出发，无法经过一系列不重复的边再回到自身。

 一个包含 `V` 个顶点和 `E` 条边的无向图是树，当且仅当：
 1. **`E = V - 1`** （边的数量恰好比顶点的数量少一个）     
 2. **图是连通的**

一个有向图是（单个）有根树，当且仅当它满足以下所有条件：

1. **唯一的根节点**：图中存在**唯一一个**入度（in-degree）为 0 的节点。这个节点就是树的根。
2. **其他节点的入度**：除了根节点外，**所有其他节点**的入度都**必须恰好为 1**。这保证了每个孩子节点只有一个父节点。
3. **连通性**：从根节点出发，可以通过有向路径到达图中的**每一个**节点。这保证了整个图是一个单一的、不中断的结构。

## 判断图中是否有环

- 无向图
```cpp
bool hascycle=false;
void dfs(int cur,int p) {
	vis[cur]=1;
	for(int next:g[cur]) {
		if(next==p) continue;
		if(vis[next]==0) dfs(next,cur);
		else {
			hascycle=true;
			return;
		}
	}
}
```

- 有向图

检测有向图环路需要更复杂的**三态DFS**。因为在有向图中，遇到一个已访问过的节点，它可能只是一个指向其他已完成分支的“横叉边”，并不一定是环。
- **状态0**: 从未访问过。
- **状态1**: 节点已访问，且正处在当前的DFS递归路径上（在递归栈中）。
- **状态2**: 节点及其所有后代节点都已探索完毕。
- 只有当我们在遍历中遇到一个“正在访问”（状态1）的节点时，才意味着发现了一个真正的环。

```cpp
bool hascycle=false;
void dfs(int cur) {
	vis[cur]=1;  // 节点已访问，且正处在当前的DFS递归路径上。
	for(int i:g[cur]) {
		if(vis[i]==1) {
			hascycle=true;
			return;
		}else if(vis[i]==0) {
			dfs(i);
		}
	}
	vis[cur]=2; // 节点及其所有后代节点都已探索完毕。
}
```

## 判断二分图

- 二分图，又称二部图，是一类结构特殊的图。它的顶点集可以划分为两个互不相交的子集，使得图中的每条边都连接这两个集合之间的一对点，而不会连接同一集合内部的点。
- 性质：
	- 图 $G$是可 2‑着色的。也就是说，可以用至多两种颜色给图的所有顶点染色，并且保证相邻顶点颜色不同。
	- 图 $G$ 中不存在奇数长度的环。
```cpp
#include <bits/stdc++.h>
#define LL long long
//#define int long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);
#define endl '\n' 
using namespace std;

int n,m;
vector<int> g[100005];
int col[100005];// 0未访问，1白色，2黑色

bool ok=true;
void dfs(int k,int c) {
    col[k] = c;
    for(auto u:g[k]) {
        if(!col[u]) {
            dfs(u,3-c);
        }
        else if(col[k] == col[u]) {
            ok=false;
            return;
        }
    }
}

signed main()
{
    IOS
    cin>>n>>m;
    for(int i=0;i<m;i++) {
        int u,v;cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for(int i=1;i<=n;i++) {
        if(!col[i]) {
            dfs(i,1);
        }
    }
    if(ok) {
        cout<<"YES\n";
        for(int i=1;i<=n;i++) {
            cout<<col[i]<<" ";
        }
    }
    else cout<<"NO";
    return 0;
}

```

## 最小生成树

- 见[[最小生成树]]

## 最短路径

- 见[[最短路径]]

## 拓补排序

- 见[[拓补排序]]

## 关键路径

- 见[[关键路径]]
