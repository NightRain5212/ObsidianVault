## 简单查找
- 线性表顺序查找：顺序存储以及链式存储
- 线性表二分查找：有序的顺序存储
- 分块查找：建立索引后先确定子表，再在子表中查找
- 散列表查找：利用hash函数对关键字进行计算后直接定位

## 二叉查找树(BST)

### 定义

二叉搜索树是一棵二叉树，它或空，或满足下面三个条件：

1. 如果树$T$的根结点的左子树非空，那么**左子树中的所有结点的键值都小于**$T$的**根结点的键值**。
2. 如果树$T$的根结点的右子树非空，那么**右子树中的所有结点的键值都大于**$T$的**根结点的键值**。
3. 树T的根结点**的左、右子树也都是二叉搜索树**。
（**no equal keys**）

- 对于一棵给定的二叉树T,如果树T中的结点的**中序是排好序的**，那么我们称树T是一棵二叉搜索树。

### 基本操作

#### 查找
- 从根开始比较，查找，比根大则往右边走查找，比根小则往左边走查找。
- **最多查找高度次**，走到空，还没找到，则这个值不存在。

#### 插入

- 树为空，则直接新增节点，赋值给root指针
- 树不为空，按二叉搜索树性质查找插入的位置，插入新节点（记录父节点，判断插入的节点应该在父节点的左子树还是右子树）

#### 删除
- 要删除的结点可能分下面四种情况：
	- 要删除的结点无孩子结点：直接删除改结点既可
	- 要删除的结点只有左孩子结点/右孩子结点：让它等于不为空的那颗树，并且释放内存
	- 要删除的结点有左、右孩子结点：寻找删除结点右子树的最小结点（右子树最左结点），将最小结点的值和删除结点的值替换，然后删除最小结点（第一种情况，可直接删除）

### 效率分析

- 最坏情况：树退化成链，$O(n)$
- 最好情况：除了最后一层，树满$O(log_2n)$

## 丰满二叉树

- 设二叉树$T$有 $n$ 个结点，$i = ⌊ log_2⁡(n+1) ⌋$，$r = n - (2i-1)$。

- 如果其中（$2i-1$）个结点放满第 $1$ 至 第 $i$ 层。
	- 若 $r = 0$，则树$T$是一棵**完美二叉树**。
	- 若 $r > 0$，且剩下的$r$ 个结点**尽量靠左地排列**在第 $i+1$ 层上，则树T是一棵**完全二叉树**。
	- 若 $r> 0$，且剩下的$r$ 个结点**随意分布**在第 $i+1$ 层，则称树T是一棵**丰满二叉树**。

若$T$同时也是查找树，则称树T是完美查找树、完全二叉查找树、丰满查找树。

## 平衡树

- 对于二叉查找树来说，丰满查找树最为有利。但对于丰满查找树进行结点的插入或删除后，很容易变成非丰满查找树。
- **平衡因子**：设$k$是二叉树$T$的结点，**左子树和右子树的高度之差**为结点$k$的平衡度。
- **平衡树**：如果二叉树$T$中**每个结点**$k$的平衡度的**绝对值都小于等于1**（即左子树和右子树的高度最多差1），那么称$T$是一棵平衡树。
- *丰满树一定是平衡树，但平衡树不一定是丰满树*。
- **平衡查找树**：如果T既是平衡树，又是查找树，那么称树T是平衡查找树（即平衡二叉查找树。**AVL树**（Adelson-Velskii and Landis）

### 定高度平衡树的最小结点数

- 结点数= 左子树结点数 + 1（根）+ 右子树结点数
$$F(h) = F(h-1)+F(h-2)+1 (h\ge 2)$$

### 定结点数的平衡树最大高度

$N$个结点的平衡树，$$h≤1.44log_2 (n+2)-0.328$$
### 基本操作

#### 插入

- 不考虑结点的平衡度，使用在查找树中插入新结点的算法，把新结点k插入树中，同时置新结点平衡度为0
- 插入新节点后，子树高度改变，也改变了平衡因子，向上走的过程中的第一个平衡因子绝对值大于1的结点，就是最小不平衡子树的根。
- 插入后破坏了平衡结构则需要旋转调整(四种情况)：(最小不平衡子树的根为A节点)
	- 在左子树的左子树上插入后破坏平衡(LL)：对A节点进行右旋转
	- 在左子树的右子树上插入后破坏平衡(LR)：先对A的左子树根左旋转，再对A右旋转
	- 在右子树的左子树上插入后破坏平衡(RL)：先对A的右子树根右旋转，再对A左旋转
	- 在右子树的右子树上插入后破坏平衡(RR)：对A节点进行左旋转
#### 平衡

- 调整平衡度，确定需要调整的范围

#### 旋转

- 改变树的形态，使得新树的高度和插入前树的高度相同，同时新树是一棵平衡查找树。
- 右旋转：
	- 当前节点与其左孩子互换父子关系。左孩子的右孩子成为当前节点的左孩子，当前节点成为其左孩子的右孩子。
- 左旋转
	- 当前节点与其右孩子互换父子关系。右孩子的左孩子成为当前节点的右孩子，当前节点成为其右孩子的左孩子。

#### 删除

- 删除根节点：
	- 空树：返回空；
	- 叶子结点：释放该结点空间后，返回空；
	- 只有左子树时：将根结点空间释放后，返回左子树；
	- 只有右子树时：将根结点空间释放后，返回右子树；
	- 当左右子树都有时：如果左子树更高，则从左子树选择最大值替换根结点，并且递归删除左子树对应结点；右子树更高，则从右子树选择最小值替换根结点，并且递归删除右子树对应结点；
	- 重新计算当前结点的树高，并且返回根结点；

- 删除非根节点：
	- 空树，不存在结点，直接返回空树
	- 要删除的值 等于 **树根结点的值**，则调用 **删除根结点** 的接口；
	- 要删除的值 小于 **树根结点的值**，递归调用删除左子树的对应结点，并且将删除结点返回的子树作为新的左子树；
	- 要删除的值 大于 **树根结点的值**，递归调用删除右子树的对应结点，并且将删除结点返回的子树作为新的右子树；
	- 最后，对于 3和 4这两步，需要对树执行 **平衡** 操作。

## 红黑树

### 定义

红黑树是满足下述性质的**二叉查找树**：
1. 每个结点或者为黑色、或者为红色。
2. **根结点为黑色**。
3. **叶结点为黑色**：每个空结点(空指针指向的是一个虚拟结点，称为空结点) 都为黑色。
4. **如果一个结点是红色的，那么它的两个孩子都是黑色**。（所以，根到叶子的所有路径，不可能存在两个连续的红色结点）
5. 从一个结点x到一个NULL指针的**每一条路径必须包含相同数目的黑色结点**。（该个数称为结点x的黑高度，记为 bh(x)，规定空结点的黑高度为0，根结点的黑高度为红黑树的黑高度 ）
**特点：左根右、根叶黑、不红红、黑路同**

### 性质

- 任意一棵有$n$个结点 (空结点不计算在$n$中) 的红黑树的高度至多为$2log(n+1)$。
- 红黑树的“平衡” ：（任意左右子树的黑高度相等）。
	- 根到叶子的所有路径中，**最长路径不会超过最短路径的2倍**，使得红黑树在最坏的情况下，也能有$O(log_2N)$的查找效率。

### 存储

- 红黑树结点中还需要增加一个颜色域color用于标识结点的颜色
- 一个指针域parent用于存储其双亲结点的位置，采用二叉链表结构存储红黑树的左右孩子结点位置。

### 基本操作

#### 插入

1. 按照二叉搜索的树规则插入新节点
2. 检测新节点插入后，红黑树的性质是否造到破坏

- 约定：**cur为当前节点，p为父节点，g为祖父节点，u为叔叔节点**
- 新插入的节点始终为红节点。
	- 空树，插入后，根结点调整为黑色。
	- P是黑色：
		- 什么也不需要做。
		- 结点x被插入后，二叉树仍然是红黑树。
	- P是红结点：
		- U节点为红色：将P和U结点染黑，G节点染红，再对G递归操作
		- U节点为黑色/空，cur是P的右孩子：将P节点作为新的当前结点，以新的当前结点为支点进行左旋。
		- U结点是黑色/空，cur是P的左孩子：将P染黑，G染红，对G右旋。

#### 删除

- 红黑树的删除删除操作分成下面三种情况：
	1. 空树：删除失败。
	2. 待删除关键字不在红黑树中：删除失败。
	3. 待删除关键字在红黑树中：红黑树首先是二叉查找树，因此先采用二叉查找树的删除操作删除关键字所在结点；然后查看是否破坏红黑树的5条性质，如果破坏，则进行调整。


## B-树

- 一棵$m$阶$B-$树是具备下列性质的树：
	- 每个结点的子结点个数$≤m$；
	- 除根和叶子之外，每个结点的子结点个数$≥⌈m/2⌉$;
	- 如果根结点不是叶子结点，则至少有两棵子树；
	- 所有叶子结点都出现在同一层上，而且不带有信息。
	- 具有$k$个子结点的非叶子结点含有$k-1个$键值。
叶子结点是终端结点，没有子结点，不带有信息。（可以看作实际上不在树中的“查找失败”的结点）。

### 基本操作

#### 查找

- B树的搜索和二叉搜索树类似，从根节点开始，从上往下递归的遍历树。在每一层节点上，使用二分查找匹配目标键，或者通过键的范围来确定子树。

#### 插入

- 对于新元素的插入，都是发生在叶子节点上的。
- 如果该节点上的元素数未满，则将新元素插入到该节点，并保持节点中元素的顺序。
- 如果该节点上的元素已满，则需要将该节点平均地分裂成两个节点：
	- 从该节点中的元素和新元素先出一个中位数
	- 小于中位数的元素放到左边节点，大于中位数的元素放到右边节点，中位数做为分隔值。
	- 分隔值被插入到父节点中（增加了树的高度），这可能会导致父节点的分裂，分裂父节点时又可能会使它的父节点分裂，以此类推。如果分裂一直上升到根节点，那么就创建一个新的根节点，它有一个分隔值和两个子节点。

#### 删除

- 删除叶子节点中的元素
	- 如果删除后产生了下溢出（键数小于最小值），则向其兄弟节点借元素。即将其父节点元素下移至当前节点，将兄弟节点中元素上移至父节点（若是左节点，上移最大元素；若是右节点，上移最小元素）
	- 若兄弟节点也达到下限，则合并兄弟节点与分割键。
- 删除内部节点中的元素
	- 内部节点中元素为其左右子节点的分割值，需要从左子节点最大元素或右子节点最小元素中选出一个新的分割值。被选中的分割符从原子节点中移除，作为新的分隔值替换掉被删除的元素。
	- 上一步中，若左右子节点元素数均达到下限，则合并左右子节点。
	- 若删除元素后，其中节点元素数小于下限，则继续合并。


## B+树


## Trie

由retrieve（检索）的中间四个字母组成，也称为“单词查找树”、前缀树、字典树等，在很多字符串相关的问题中应用广泛，比如存储字典、求最长公共前缀，搜索引擎系统单词比较等。它能够高效地支持字符串的插入、查找和前缀匹配操作

### 结构

- Trie树是一棵m次树（m>=2）：
	- 根结点不包含字符，其他每个结点都包含一个字符；
	- 从根结点到某一结点，路径上经过的字符连接起来，即为该结点对应的字符串；
	- 每个结点的所有子结点包含的字符都不相同；
	- 通常使用一个结束标志来表示某个结点是否为单词的结尾。

### 基本操作

#### 查找

- 在一棵Trie树中查找字符串$x$，必须把$x$分割成单个字符,然后从Trie树的根结点开始逐个字符匹配,如果最后遇到标记则说明找到$x$

#### 插入

- 在一棵Trie树中插入字符串x，从Trie树的根结点开始对于字符串x的每个字符，检查是否存在当前字符对应的子结点。
- 如果子结点存在，沿着指针移动到子结点，继续检查下一个字符。
- 如果子结点不存在，创建一个新的子结点并加入当前结点的子结点集合。沿着指针移动到子结点，继续处理下一个字符。
- 重复以上步骤，直到处理完字符串的最后一个字符，最后创建一个新的结束标记结点。

#### 删除

- 在Trie树删除字符串x可能存在三种情况：
	- 字符串x独立存在，整个删除
	- 字符串x是其它字符串的前缀，修改结束标记
	- 字符串x与其它字符串有公共前缀，保留公共前缀


