

# 基本概念

- 贪心算法是一种在**每个决策点上都采取当前看起来最优选择**的算法设计范式。简单来说，它遵循“**局部最优**”的原则，期望通过一系列的局部最优解，最终能够得到一个“**全局最优**”的解。
- 贪心算法在有**最优子结构**的问题中尤为有效。**最优子结构**的意思是问题能够**分解成子问题**来解决，**子问题的最优解能递推到最终问题的最优解**。

# 基本要素

- **贪心选择性质**：所谓贪心选择性质是指**所求问题的全局最优解可以通过一系列局部最优的选择，即贪心选择来达到**。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。
- **最优子结构性质**：**当一个问题的最优解包含其子问题的最优解**时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的**关键特征**。

# 证明贪心算法正确性的基本思想

- 证明贪心算法正确性=证明其具有贪心选择性质和最优子结构性质。
- 证明最优子结构性质：考虑反证法，先按贪心思路构造最优解集合，证明前一步的集合是否是子问题的最优解集合，假设前一步的集合是否不是子问题的最优解集合，则推出选择后的集合不是最优的，与假设矛盾。
- 证明贪心选择性质：要证明 贪心选择的结果 存在于某个最优解集合中。也可以先假设构造出一个最优解集合，并证明贪心选择的结果一定在此最优解集合中。


# 找零问题的贪心策略

- **找零问题**：考虑用最少的硬币找n美分零钱的问题。假定每种硬币的面额都是整数。
## 设计贪心算法，证明算法能找到最优解。

- 设计贪心算法求解找零问题，假定有25美分、10美分、5美分和1美分4种面额的硬币。证明你的算法能找到最优解。
- **设计思想**：**优先选择面额大的硬币**。

证明如下：

- 最优子结构性质

设$S=\{a,b,c,d\}$候选为25，10，5，1的最优解集合，其中$a,b,c,d$分别为$25,10,5,1$美分硬币的数量，有$25a+10b+5c+d=n$。

由于$S = \{a\} \cup S'$，$S'=\{b,c,d\}$，要证$S'$为10，5，1的最优解集合。
若$S'$不是最优解，则存在更优的解集合$S^* = \{b',c',d'\}$，有$b'+c'+d' < b+c+d$ 则，$a+b'+c'+d'<a+b+c+d$，则$S$ 不是最优解集合，与假设矛盾，故$S'$是最优解。

同理，$S' = \{b\}\cup S''$，$S''=\{c,d\}$也是5，1的最优解集合.......

- 贪心选择性质

设 $n$ 美分从25，10，5，1中最多能选 $a$ 张25，要证明 $a$ 存在于某个最优解集合中。

假设一个最优解集合 $S_0 =\{a_0,b_0,c_0,d_0\}$ ，已知$n-25a<25$，所以必有$a_0\le a$。

若$a_0 = a$，则$a$存在于最优解集合$S_0$中。

若$a_0<a$，设$a_0=a-k$，且25美分若不用25的硬币凑需要至少3个硬币(10+10+5)，

即
$$25a_0+10b_0+5c_0+d_0=n\Rightarrow 25a+10b_0+5c_0+d_0=n+25k$$$$25a+10(b_0-2k)+5(c_0-k)+d_0=n$$
显然，$a+b_0-2k+c_0-k+d_0 < a_0+b_0+c_0+d_0$，故$S_0$不是最优解，与假设矛盾！

故一定 $a$ 存在于某个最优解集合中。

## 扩展硬币面额证明贪心算法正确性

- 硬币面额为 $c^0,c^1,c^2,...,c^k$，$c>1,k\ge1$，证明贪心算法正确性。

证明如下：

- 最优子结构性质

设$S=\{i_0,i_1,...,i_k\}$候选为最优解集合，其中$i_j$分别为$c^j$美分硬币的数量（$0\le j\le k$），有$\sum_{j=0}^k c^j\times i_j=n$。

由于$S = \{i_k\} \cup S'$，$S'=\{i_0,i_1,...,i_{k-1}\}$，要证$S'$为$\{c^0,c^1,...,c^{k-1}\}$的最优解集合。
若$S'$不是最优解，则存在更优的解集合$S^* = \{i'_0,i'_1,...,i'_{k-1}\}$，有$\sum_{n=0}^{k-1}i'_n < \sum_{n=0}^{k-1} i_n$ 则，$i_k+\sum_{n=0}^{k-1}i'_n <i_k+\sum_{n=0}^{k-1}i_n$，则$S$ 不是最优解集合，与假设矛盾，故$S'$是最优解。

再往下拆分的子问题同理。

- 贪心选择性质

设 $n$ 美分从$c^0,c^1,c^2,...,c^k$中最多能选 $i_k$ 张$c^k$，要证明 $i_k$ 存在于某个最优解集合中。

假设一个最优解集合 $S_j =\{j_0,j_1,...,j_k\}$ ，已知$n-c^ki_k<c^k$，所以必有$j_k\le i_k$。

若$j_k = i_k$，则$i_k$存在于最优解集合$S_j$中。

若$j_k<i_k$，设$j_k=i_k-m$，且$c^k = c^{k-1}\cdot c$，所以不用$c^k$的话，一个$c^k$至少需要$c$张$c^{k-1}$凑出

所以
$$\sum_{t=0}^k c^tj_t=n\Rightarrow c^ki_k+\sum_{t=0}^{k-1}c^tj_t=n+mc^k=n+c^{k-1}(mc)$$$$c^ki_k+c^{k-1}(j_{k-1}-mc)+\sum_{t=0}^{k-2} c^tj_t=n$$
显然，$i_k+j_{k-1}+\sum_{t=0}^{k-2} j_t-mc<i_k-m+\sum_{t=0}^{k-1}j_t$，故$S_j$不是最优解，与假设矛盾！

故一定 $i_k$ 存在于某个最优解集合中。

## 设计一组硬币面额，找出贪心算法的反例

- 设计一组硬币面额，使得贪心算法不能保证得到最优解。这组硬币面额中应该包含1美分，使得对每个零钱值都存在找零方案

硬币面额举例：1美分，3美分，5美分，6美分。若要组成8美分的面额，按贪心策略是3张(6+1+1)，然而实际上只需要2张(3+5)

## 设计一个找零算法,适用于任何 $k$ 种不同面额的硬币。(DP)

- 设计一个 $O(nk)$ 时间的找零算法,适用于任何 $k$ 种不同面额的硬币，假定总是包含1美分硬币。

假设 $k$ 种不同面额的硬币面额分别为$c[1],c[2],...,c[k]$。

由于其最优子结构性质考虑dp，设状态$dp[i]$为使用找零$i$美分使用的硬币最少值。

考虑凑$i$美分的情况，显然，$dp[i-c[1]],dp[i-c[2]],...,dp[i-c[k]] \rightarrow dp[i]$，共有$k$个子问题。

考虑状态转移
$$dp[i] = 1+ \min_{1\le m\le k}{dp[i-c[m]]}$$
因为有两个维度$n,k$需要迭代转移状态，直接转移的复杂度为$O(nk)$


## 练习题

- 例题： [P2842 纸币问题 1 - 洛谷](https://www.luogu.com.cn/problem/P2842)



# 常见解法

## **排序解法**

- 用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。

### 活动安排问题

现在有 $n$ 个比活动，每个活动的开始、结束的时间点是知道的。求最多能参加的活动数目。

思路：将活动的截止时间从小到大排序，优先选择靠前的活动，依次考虑每个活动的时间是否在合法范围内（起始时间 $\ge$ 上个活动的终止时间），若合法则选择即可。

思考：选择活动的起始时间排序，或活动的持续时间排序是否能得出最优解，为什么

- 例题： [P1803 凌乱的yyy / 线段覆盖 - 洛谷](https://www.luogu.com.cn/problem/P1803)

```cpp
#include <bits/stdc++.h>
#define ll long long
//#define int long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);
#define endl '\n' 
const int inf = 0x3f3f3f3f;
const ll infll = 0x3f3f3f3f3f3f3f3f;
const double PI = acos(-1.0);
using namespace std;
//ifstream fin("input.txt");
//ofstream fout("output.txt");
//#define cin fin
//#define cout fout
int n;
const int N = 1e6+5;

struct act {
    int a,b;
}acts[N];

bool cmp(act& a,act& b) {
    return a.b<b.b;
}


signed main()
{
    IOS
    cin>>n;
    for(int i=1;i<=n;i++) {
        cin>>acts[i].a>>acts[i].b;
    }
    sort(acts+1,acts+1+n,cmp);
    int ans=0;
    int lastend=0;
    for(int i=1;i<=n;i++) {
        if(acts[i].a>=lastend) {
            lastend = acts[i].b;
            ans++;
        }
    }
    cout<<ans;

    //fin.close(),fout.close();
    return 0;
}

```




## **邻项交换法**

- 保证交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。

- **例题** ： [国王游戏]( https://www.luogu.com.cn/problem/P1080 )
- **题意**：恰逢 H 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。

- 思路如下：假设经过恰当排序后，考虑队列中的第$i$个人和第$i+1$个人， 设：$\Pi_{k=1}^{i-1}a_i = S$，则他们的奖赏为$\frac{S}{b_i}$，$\frac{Sa_i}{b_{i+1}}$。如果将他们交换后则奖赏变为$\frac{S}{b_{i+1}}$，$\frac{Sa_{i+1}}{b_i}$，由于交换后并不会得到比目前更优的方案，所以有$max(\frac{S}{b_i},\frac{Sa_i}{b_{i+1}}) < max(\frac{S}{b_{i+1}},\frac{Sa_{i+1}}{b_i})$，化简可得$max(b_{i+1},a_ib_i) < max(b_i,a_{i+1}b_{i+1})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int const N = 5010;

struct Num {
    vector<int> digits;

    Num() {
        digits = vector<int>(N, 0);
    }

    Num(int k) {
        digits = vector<int>(N, 0);
        int i = 0;
        while (k) {
            digits[i++] = k % 10;
            k /= 10;
        }
    }

    Num operator*(Num const &b) {
        Num ans;
        for (int i = 0; i < N; i++) {
            for (int j = 0; j <= i; j++) {
                ans.digits[i] += digits[j] * b.digits[i - j];
            }
        }
        for (int i = 0; i < N - 1; i++) {
            if (ans.digits[i] > 9) {
                ans.digits[i + 1] += ans.digits[i] / 10;
                ans.digits[i] %= 10;
            }
        }
        if (ans.digits[N - 1] > 9) {
            ans.digits.push_back(ans.digits[N - 1] / 10);
            ans.digits[N - 1] %= 10;
        }
        return ans;
    }

    Num operator/(int b) {
        Num ans;
        int r = 0;
        for (int i = N - 1; i >= 0; i--) {
            int cur = r * 10 + digits[i];
            ans.digits[i] = cur / b;
            r = cur % b;
        }
        return ans;
    }

    Num operator*(int k) {
        Num ans;
        for (int i = 0; i < N; i++) {
            ans.digits[i] = digits[i] * k;
        }
        for (int i = 0; i < N - 1; i++) {
            if (ans.digits[i] > 9) {
                ans.digits[i + 1] += ans.digits[i] / 10;
                ans.digits[i] %= 10;
            }
        }
        if (ans.digits[N - 1] > 9) {
            ans.digits.push_back(ans.digits[N - 1] / 10);
            ans.digits[N - 1] %= 10;
        }
        return ans;
    }

    void print() {
        int index = N - 1;
        while (index >= 0 && digits[index] == 0) {
            index--;
        }
        if (index < 0) {
            cout << 0;
            return;
        }
        while (index >= 0) {
            cout << digits[index--];
        }
    }

    bool cmp(Num const &other) {
        int ia = N - 1, ib = N - 1;
        while (ia >= 0 && digits[ia] == 0) {
            ia--;
        }
        while (ib >= 0 && other.digits[ib] == 0) {
            ib--;
        }
        if (ia != ib) {
            return ia > ib;
        }
        while (ia >= 0 && ib >= 0 && digits[ia] == other.digits[ib]) {
            ia--;
            ib--;
        }
        if (ia < 0) {
            return 0;
        }
        return digits[ia] > other.digits[ib];
    }
};

struct node {
    long long a;
    long long b;

    bool operator<(node const &other) {
        return max(other.b, a * b) < max(b, other.a * other.b);
    }
};

int main() {
    int n;
    cin >> n;
    int a, b;
    cin >> a >> b;
    Num ans;
    vector<node> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i].a >> v[i].b;
    }
    sort(v.begin(), v.end());
    Num pre(a);

    for (int i = 0; i < v.size(); i++) {
        Num cur = pre / v[i].b;
        if (cur.cmp(ans)) {
            ans = cur;
        }
        pre = pre * v[i].a;
    }
    ans.print();

    return 0;
}

```


## 后悔法

- 思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。

- **例题**：[Work Scheduling](https://www.luogu.com.cn/problem/P2949)
- **题意**：他的工作日从时间 $0$ 开始，总共有 $10^9$ 个时间单位。他目前可以从 $N$ ($1 \leq N \leq 10^5$) 项工作中选择要做的工作，这些工作被方便地编号为 $1$ 到 $N$。虽然理论上他有可能完成所有 $N$ 项工作，但实际上这是极不可能的，因为他在任何一个时间单位内只能完成一项工作，而截止日期通常会导致他无法完成所有任务。第 $i$ 项工作的截止时间为 $D_i$ ($1 \leq D_i \leq 10^9$)。如果他在截止时间前完成第 $i$ 项工作（如果当前时间为 $t$，那么仅当 $D_i > t$ 的时候他能做这个任务，完成后 $t \rightarrow t+1$），他将获得 $P_i$ ($1 \leq P_i \leq 10^9$) 的利润。给定一系列工作和截止日期，FJ 能够获得的最大总利润是多少？答案可能无法容纳在 $32$ 位整数中。

- 思路：先将各项工作按截止时间排序，维护一个优先队列(利润值小顶堆)(已选工作队列)；选择第$i$个工作时，如果当前时间空余，且符合截止时间要求，直接入队。若当前时间均已排满，而此工作比已选的工作利润大，则反悔，将优先队列队首出队，将工作入队。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

struct job{
    ll d;
    ll p;
};

bool cmp(const job& a,const job& b) {
    if(a.d != b.d) return a.d<b.d;
    return a.p>b.p;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;cin>>n;
    priority_queue<ll,vector<ll>,greater<>> pq;
    vector<job> v(n);
    for(int i=0;i<n;i++) {
        cin>>v[i].d>>v[i].p;
    }
    sort(v.begin(),v.end(),cmp);
    ll w=0;
    for(int i=0;i<n;i++) {
        if(pq.size() == v[i].d) {
            if(v[i].p>pq.top()) {
                pq.pop();pq.push(v[i].p);
            }
        } else {
            pq.push(v[i].p);
        }
    }
    while(!pq.empty()) {
        w+=pq.top(); pq.pop();
    }
    cout<<w;

    return 0;
}

```


# 参考

- [贪心 - OI Wiki](https://oi-wiki.org/basic/greedy/)
