
- 参考：[最短路 - OI Wiki](https://oi-wiki.org/graph/shortest-path/)
# dijkstra

- Dijkstra 算法用于解决 **单源最短路径问题**（Single-Source Shortest Path），即在带权有向[[图]]或无向[[图]]中，找到从某个源点到所有其他顶点的最短路径。
- 核心思想是 **贪心策略**

### **核心步骤**

1. **初始化**：
    - 设置源点 `s` 的距离为 `0`（`dist[s] = 0`）。
    - 其他顶点的距离初始化为无穷大（`dist[v] = ∞`）。
    - 所有顶点标记为未访问。
2. **选择当前最短路径顶点**：
    - 从未访问的顶点中选择 `dist[u]` 最小的顶点 `u`。
3. **松弛操作（Relaxation）**：
    - 遍历 `u` 的所有邻接顶点 `v`，更新其最短距离：
4. **标记已访问**：
    - 将 `u` 标记为已访问，不再处理。
5. **重复**：
    - 直到所有顶点均被访问。

### 局限性

1. **不支持负权边**：
    - 若存在负权边，贪心策略可能失效（因后续路径可能通过负权边缩短距离）。
2. **无法处理负权环**：
    - 负权环会导致无限松弛（路径长度可无限减小）。

- 实现：
```cpp
void dj() {
	//初始化dist
    for(int i=1;i<=n;i++) {
        dist[i]=inf;
    }
    dist[s]=0;
    cnt[s]=1; //cnt用于计算最短路径条数，起点为1，其他初始为0
    //堆优化
    priority_queue<pair<int,int>> pq;
    pq.push({0,s});
    while(!pq.empty()) {
        int now = pq.top().second;
        pq.pop();
        if(vis[now]) continue;
        vis[now]=1;
        //松弛
        for(auto k:g[now]) {
            int next = k.first;
            int w = k.second;
            if(dist[now]+w<dist[next]) {
                dist[next] = dist[now]+w;
                cnt[next]=cnt[now]; // 更新最短路径条数next=now
                //默认大顶堆，使用负权值实现小顶堆
                pq.push({-dist[next],next}); 
                pre[next] = now; // 记录路径
            } else if (dist[now]+w==dist[next]) {
                cnt[next]+=cnt[now]; // 更新最短路径条数next+=now
            }
        }
    }
}
```

- 复杂度：$O((V+E)logV)$
- [P4779 【模板】单源最短路径（标准版） - 洛谷](https://www.luogu.com.cn/problem/P4779)

# floyd


- 适用于解决小规模图的**多源最短路径**问题
- 允许[[图]]中存在负权边
- 可判断图中是否存在负权环（检查算法结束后图中是否存在顶点到自身的最短路径为负数）。

- 实现
```cpp
void floyd() {
    for(int k=1;k<=n;k++) {
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=n;j++) {
                dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j]);
            }
        }
    }
}
```
- 记录最短路径：
	- `path[i][j]` ：存储的是从顶点 `i` 到顶点 `j` 的最短路径上，**顶点 `k`** (即那个使得 `dist[i][k] + dist[k][j]` 最小的中间顶点)。
```cpp
void floyd() {
    for(int k=1;k<=n;k++) {
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=n;j++) {
	            if(dist[i][k]+dist[k][j] < dist[i][j])
                {
	                dist[i][j] = dist[i][k]+dist[k][j];
	                path[i][j] = k // 记录这个使得路径变短的中间顶点 k
                }
            }
        }
    }
}
```

- **时间复杂度**：$O(n^3)$
- [P1359 租用游艇 - 洛谷](https://www.luogu.com.cn/problem/P1359)


# Bellman-Ford


- Bellman–Ford 算法是一种**基于松弛**（relax）操作的最短路算法，**可以求出有负权的图的最短路**，并可以**对最短路不存在的情况进行判断**
- 对于边 $(u,v)$ ，**松弛操作**对应下面的式子 $dis(v) = \min(dis(v), dis(u) + w(u, v))$．
- Bellman–Ford 算法所做的，就是**不断尝试对图上每一条边进行松弛**．我们**每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作**，当一次循环中**没有成功的松弛操作时，算法停止**
- 每次循环是 $O(m)$ 的，在最短路存在的情况下，由于一次松弛操作会使最短路的边数至少增加一，而最短路的边数最多为 $n-1$，因此整个算法最多执行 $n-1$ 轮松弛操作．故总时间复杂度为 $O(nm)$．
```cpp
for(int i=0;i<n-1;i++) {
	for(auto& [u,v,w]:edges) {
		if(dist[u]+ w < dist[v]) {
			dist[v] = dist[u] + w;
		}
	}
}
```
- **检查负环**：再进行一次循环，对于任意一条边 $(u, v)$，其权重为 $w(u, v)$，满足以下不等式：
$$dist[v] > dist[u] + w(u, v)$$
即：**$u$ 到源点的距离 + 边 $(u,v)$ 的权重 < $v$ 当前记录的最短距离**，那么图中存在负权环。
```cpp
for(auto& [u,v,w]:edge) {
	if(dist[u] + w < dist[v]) {
		if(dist[u]>=1e9 && dist[v]>=1e9) continue;
		neg=1;
		break;
	}
}
```
- 标准的 Bellman-Ford 算法只能检测**从源点可达**的负权环。如果负权环在图的一个孤立分量中（源点无法到达），上述算法中的 $dist[u]$ 会一直保持无穷大，判定条件可能不会触发。只能说明从 $S$ 点出发不能抵达一个负环，而**不能说明图上不存在负环**．
- 如果需要判断整个图上是否存在负环，最严谨的做法是**建立一个超级源点**，**向图上每个节点连一条权值为 0 的边**，然后以超级源点为起点执行 Bellman–Ford 算法．
- 板子题：[P3385 【模板】负环 - 洛谷](https://www.luogu.com.cn/problem/P3385)

# SPFA

- 队列优化：Shortest Path Faster Algorithm．
- 很多时候我们并不需要那么多无用的松弛操作．
- 很显然，**只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作．**
- 用**队列来维护**「**哪些结点可能会引起松弛操作**」，就能只访问必要的边了．
- SPFA 也可以用于判断 $s$ 点是否能抵达一个负环，只需记录最短路经过了多少条边，当经过了至少 $n$ 条边时，说明 $s$ 点可以抵达一个负环．
```cpp
bool spfa(int s) {
    dist[s]=0,vis[s]=1;
    queue<int> q;
    q.push(s);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        vis[u]=0;
        for(auto [v,w]:g[u]) {
            if(dist[v] > w + dist[u]) {
                dist[v] = w+dist[u];
                cnt[v] = cnt[u]+1; // 记录最短路上有几条边
                if(cnt[v] >= n) return 0; // 负环
                if(!vis[v]) q.push(v),vis[v]=1;
            }
        }
    }
    return 1;
}
```
- 虽然在大多数情况下 SPFA 跑得很快，但其最坏情况下的时间复杂度为$O(nm)$
- 板子题：[P3385 【模板】负环 - 洛谷](https://www.luogu.com.cn/problem/P3385)

