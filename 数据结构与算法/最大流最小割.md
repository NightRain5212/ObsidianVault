
# 流网络

**流网络**（network）是指一个特殊的**有向图** $G=(V,E)$，其与一般有向图的不同之处在于**有容量和源汇点**。**不存在反向平行边**。

- $E$ 中的每条边 $(u,v)$ 都有一个被称为**容量**（*capacity*）的权值，记作  $c(u, v)$。当 $(u,v)\not \in E$ 时，可以假定 $c(u,v)=0$。
- $V$ 中有两个特殊点：源点 $s$ （入度为0），汇点 $t$ （出度为0），$s\not = t$.

## 网络流

**流**（flow）是一个从边集 $E$ 到整数集或实数集的函数 $f$，其满足以下性质。

- **容量限制**：对于每条边，流经该边的流量不得超过该边的容量
$$0\le f(u,v) \le c(u,v)$$
- **流守恒性**：除源汇点外，任意结点的净流量为 0。(**流入量=流出量**)
- 结点 $u$ 的净流(出)量
$$f(u) = \sum_{x\in V} f(u,x) - \sum_{x\in V} f(x,u) = 0$$
- 对于有向图 $G$，$f$ 的流量为 $|f|$，源点的净流出量，汇点的净流入量。（符号仅仅表示方向）

$$|f| = \sum_{x\in V} f(s,x) = -\sum_{x\in V} f(x,t)$$
## 切割

对于网络 $G =(V,E)$ ，如果 $\{S,T\}$ 是 $V$ 的划分 (即 $S\cup T =V 且 S\cap T = \emptyset$)，且满足 $s \in S,t\in T$，则我们称 $\{S,T\}$ 是 G 的一个 $s-t$ 割 (cut)。

我们定义 $s-t$ 割 $\{S,T\}$ 的容量为 $||S,T||$
$$||S,T|| = \sum_{u\in S,v\in T} c(u,v)$$

定义 $s-t$ 割 $\{S,T\}$ 的净流量为 
$$f(S,T) = \sum_{u\in S,v\in T} f(u,v) - \sum_{u\in S,v\in T}f(v,u)$$


# 最大流问题

给定一个流网络 $G$，一个源结点 $s$ 和一个汇点 $t$ , 希望找到一个流 $f$，其值达到最大。

# Ford–Fulkerson 增广

Ford–Fulkerson 增广是计算最大流的一类算法的总称。该方法运用贪心的思想，通过寻找增广路来更新并求解最大流。

## 剩余容量

对于边$(u,v)$，其容量与流量之差为**剩余容量**
$$c_f(u,v) = c(u,v) - f(u,v)$$

## 残存网络

我们将 $G$ 中所有结点和**剩余容量大于 0 的边构成的子图**称为**残量网络** $G_f$（Residual Network）

$$G_f = (V,E_f) ,E_f = \{(u,v)|c_f(u,v) > 0\}$$
- $E_f$ 中的边对应原本流网络中的边或反向边。$|E_f| \le 2|E|$

## 残存边

对于流网络的边$e = (u,v)$，增加反向边$e^R = (v,u)$，用于回流反悔。
$$c_f(e)=\begin{cases}c(e)-f(e)&\text{if }e\in E\\f(e)&\text{if }e^R\in E\end{cases}$$
当正流量$f(u,v)$减小时，其剩余容量增加$k$，对应地，其反向边剩余容量减小$k$。

## 增广路径

给定流网络 $G=(V,E)$ 和流 $f$ , **增广路径** $p$ 是残存网络 $G_f$ 中一条从源结点 $s$ 到汇点 $t$ 的简单路径。

一条增广路径 $p$ 上**能够为每条边增加的流量的最大值**为路径 $p$ 的残存容量
$$c_f(p) = \min \{c_f(u,v)|(u,v)\in p\}$$

# 最大流最小割定理

设 $f$ 是流网络 $G=(V,E)$ 中的一个流，该流网络的源结点 $s$ , 汇点 $t$ ，则下面的条件是等价的:

- $f$ 是流网络 $G$ 的最大流
- 残存网络 $G_f$ 中不包含增广路径
- $|f| = c(S,T) = ||S,T||$，其中$\{S,T\}$是流网络 $G$ 的某个切割。
- 最大流 $f$ 和最小割 $\{S,T\}$ 总是满足 $|f| = ||S,T||$
- 特殊地，**当最小割中所有边权均为 1 时，最小割容量即为最小割边集的大小。**

# Ford–Fulkerson 算法

- 初始化流网络中的流函数为0
$$\forall (u,v)\in E,f(u,v) = 0$$
- 寻找流 $f$ 诱导的残存网络 $G_r$ 的一条增广路径 $p$，使用增广路径 $p$ 来对流$f$ 进行修改，从而获得一个值更大的流。
- 重复执行步骤二，直到在残存网络中不再存在增广路径为止，此时流 $f$ 就是最大流。
- 时间复杂度：$O(|E||f|_{max})$，与最大流的数值有关


# Edmonds–Karp 算法

- 在残存网络中，从 $s$ 点开始bfs到 $t$ ，寻找增广路。
- 记录增广路中边的剩余容量最小值 $\Delta = \min_{(u,v)\in G_f}c_f(u,v)$ 
- 将增广路上的每一边的剩余容量减去$\Delta$，反向边加上$\Delta$。记录的答案$f_{max}$ 加上$\Delta$
- 重复步骤直到残存网络不存在增广路时，算法结束。
- 时间复杂度：$O(VE^2)$


- [P3376 【模板】网络最大流 - 洛谷](https://www.luogu.com.cn/problem/P3376)
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define int long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);
#define endl '\n' 
const int inf = 0x3f3f3f3f;
const ll infll = 0x3f3f3f3f3f3f3f3f;
const double PI = acos(-1.0);
using namespace std;
//ifstream fin("input.txt");
//ofstream fout("output.txt");
//#define cin fin
//#define cout fout

int n,m,s,t;

const int N = 1e5+10;

int head[N]; // head[u]表示以u为起点的第一条边的编号
int to[N];   // 表示编号为i的边的终点
int nxt[N];  // 编号为i的边的下一条同起点的边
int idx;     // 边的编号
ll cf[N];    // 编号为i的边的剩余容量
ll mf=0;     // 最大流
ll incf[N];

inline void add(int u,int v,ll w) {
    to[idx]=v;
    cf[idx]=w;
    nxt[idx]=head[u];
    head[u]=idx++;
}
	
bool vis[N];
int pre[N];
inline bool bfs() {
    memset(vis,0,sizeof(vis));
    vis[s]=1;
    queue<int> q;
    q.push(s);
    incf[s]=infll;
    while(!q.empty()) {
        int u = q.front();
        q.pop();
        for(int i=head[u];i!=-1;i=nxt[i]) {
            if(cf[i]) {
                int v = to[i];
                if(vis[v]) continue;
                vis[v]=1;
                incf[v] = min(incf[u],cf[i]);
                pre[v]=i;
                q.push(v);
                if(v==t) return 1;
            }
        }
    }
    return 0;
}

inline void ek() {
    while(bfs()) {
        int p=t;
        while(p!=s) {
            int i=pre[p];
            cf[i]-=incf[t];
            cf[i^1]+=incf[t];
            p = to[i^1];
        }
        mf+=incf[t];
    }
}

signed main()
{
    IOS
    cin>>n>>m>>s>>t;
    memset(head,-1,sizeof(head));
    for(int i=1;i<=m;i++) {
        int u,v;ll w;
        cin>>u>>v>>w;
        add(u,v,w);
        add(v,u,0);
    }
    ek();
    cout<<mf;

    //fin.close(),fout.close();
    return 0;
}
```

# 合并权值最小割

[P1344 [USACO4.4] 追查坏牛奶 Pollutant Control - 洛谷](https://www.luogu.com.cn/problem/P1344)

两个输出，实际上是最少边的最小割的容量和边的数量。
已知，**当最小割中所有边权均为 1 时，最小割容量即为最小割边集的大小。**
将两个信息压缩成一个信息跑一次最大流最小割的思想：**权值合并**

用数量级隔离，把“损失”作为高位，“边数”作为低位，从而用一次最小割完成字典序优化。

若构造新的权值$C'_i$
$$C_i' = C_i \times P + a_i$$
则有
$$C_i = C_i' /P , a_i = C_i' \%P $$
其中为了保证取余正确，要保证$P > |E|$，要比原来的边的数量大，保证前一个指标的权重大于第二个指标（保证在割容量最小的前提下，最小割的边数最小）

```cpp
#include <bits/stdc++.h>
#define ll long long
#define int long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);
#define endl '\n' 
const int inf = 0x3f3f3f3f;
const ll infll = 0x3f3f3f3f3f3f3f3f;
const double PI = acos(-1.0);
using namespace std;
//ifstream fin("input.txt");
//ofstream fout("output.txt");
//#define cin fin
//#define cout fout

const int N = 40;
const int M = 2010;
const int P = 3000;
int s,t;
int n,m;

// 最大流最小割ek算法
struct graph {
    int head[M],nxt[M],to[M],c[M],idx;
    int mf=0;
    bool vis[N];
    int incf[N];
    int pre[N];
    graph() {
        memset(head,-1,sizeof(head));
        idx=0;
    }

    void add_edge(int u ,int v,int w) {
        to[idx]=v;
        c[idx]=w;
        nxt[idx]=head[u];
        head[u]=idx++;
    }
    bool bfs() {
        memset(vis,0,sizeof(vis));
        queue<int> q;
        vis[s]=1;
        q.push(s);
        incf[s]=inf;
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            for(int i=head[u];i!=-1;i=nxt[i]) {
                if(c[i]) {
                    int v=to[i];
                    if(vis[v]) continue;
                    vis[v]=1;
                    incf[v] = min(incf[u],c[i]);
                    q.push(v);
                    pre[v]=i;
                    if(v==t) {
                        return 1;
                    }
                }
            }
        }
        return 0;
    }
    void ek() {
        while(bfs()) {
            int p = t;
            while(p!=s) {
                int i=pre[p];
                c[i]-=incf[t];
                c[i^1]+=incf[t];
                p=to[i^1];
            }
            mf+=incf[t];
        }
    }

} g1;



signed main()
{
    IOS
    cin>>n>>m;
    s=1,t=n;
    for(int i=0;i<m;i++) {
        int u,v,w;cin>>u>>v>>w;
        // 合并权值
        g1.add_edge(u,v,w*P+1);
        g1.add_edge(v,u,0);
    }
    // 跑一次最大流
    g1.ek();
    // 得到结果
    cout<<g1.mf/P<<" "<<g1.mf%P;
    //fin.close(),fout.close();
    return 0;
}
```

