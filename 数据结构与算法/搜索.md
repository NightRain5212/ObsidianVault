
## DFS

深度优先搜索。在 **搜索算法** 中，该词常常指利用**递归函数**方便地实现**暴力枚举**的算法，与图论中的 DFS 算法（“一路走到黑，不撞南墙不回头”）有一定相似之处，但并不完全相同。

通常配合回溯来枚举所有的合法解。

```cpp
void dfs(传入数值) 
{ 
	if (到达目的地) 
		ans = 从当前解与已有解中选最优; 
	for (遍历所有可能性) {
		if (可行) { 
			进行操作; 
			dfs(缩小规模); 
			撤回操作; 
		}
	}
}
```

**优点:**
- **空间效率高：** 由于DFS只需要存储从起始节点到当前节点的路径，其空间复杂度相对较低，特别是在图的分支非常多但深度不大的情况下。
- **实现简单：** 使用递归实现DFS的代码通常非常简洁。
- **能找到所有解：** 如果问题需要找到所有可能的解（而不仅仅是最优解），DFS是一个非常合适的选择，因为它会遍历每一条路径。
- **适用于检测环路和拓扑排序：** DFS非常适合用来检测图中是否存在环路，以及对有向无环图（DAG）进行拓扑排序。

**缺点:**
- **不保证找到最短路径：** 由于其“深入”的特性，DFS找到的第一个解不一定是最优的或最短的。它可能会在一个很深的分支中找到一个解，而一个更优的解可能存在于一个较浅但未被探索的分支中。
- **可能陷入无限循环：** 在处理包含循环的图时，如果不加以处理（例如，标记已访问节点），DFS可能会陷入无限循环。
- **递归过深可能导致栈溢出：** 如果图的深度非常大，使用递归实现的DFS可能会因为调用栈过深而导致栈溢出。


## BFS

宽度优先搜索。就是每次都尝试访问同一层的节点。（层层推进） 如果同一层都访问完了，再访问下一层。这通过队列实现

```cpp
void bfs() {
	queue<int> q;
	q.push(起点);
	vis[起点]=1;
	while(!q.empty()){
		当前点 = q.front();
		q.pop();
		for(所有可能的下一个点) {
			if(vis[下一个点]) continue;
			vis[下一个点]=1;
			q.push(下一个点)
		}
	}
}
```


**优点:**
- **保证找到最短（优）路径：** 在所有边的权重都相同的无权图中，BFS能够保证找到从起始节点到目标节点的最短路径。这是因为它总是先探索距离近的节点。
- **不会陷入无限循环：** 只要正确地标记已访问节点，BFS在包含循环的图中也能正常工作，因为它逐层扩展，不会在单一路径上无限深入。
- **适用于寻找连通分量：** 可以用来找出图中所有的连通分量。

**缺点:**

- **空间消耗大：** BFS需要一个队列来存储待访问的节点。对于宽度非常大的图，队列中可能需要存储大量的节点，导致内存消耗巨大。
- **不适用于寻找所有解：** 如果问题的目标是找到所有可能的解，BFS通常不是最佳选择，因为它会系统地探索所有可能性，而不是专注于一条路径。

## 0-1 BFS

0-1 BFS 是一种用于在**加权图**中寻找**单源最短路径**的算法。它的特殊之处在于，它只适用于图中所有边的权重（代价）**仅为 0 或 1** 的情况。通过使用**双端队列 (deque)** 获得了更高的时间效率。

0-1 BFS 的精髓在于它如何使用双端队列 `deque` 来维护节点的处理顺序。

1. 当你沿着一条**权重为 0** 的边 `u -> v` 进行扩展时，将节点 `v` 加入到双端队列的**队头**
2. 当你沿着一条**权重为 1** 的边 `u -> w` 进行扩展时，将节点 `w` 加入到双端队列的**队尾**

这保证了每次从队头取出的节点，一定是当前所有待处理节点中距离最小的那个。

### 例题

- 题意：你被置于一个由空格和墙壁组成的二维地图中。找到一条从起点`(1,1)`到终点`(n,m)`的路径，使得路径上**破坏尽可能少的墙壁**。
- 这道题就是要你在一个带权重的网格中，寻找一条从起点到终点的最短路径（最小代价路径）。在这个网格中，穿过空格的代价是0，穿过墙的代价是1。

```cpp
#include <bits/stdc++.h>
#define LL long long
//#define int long long
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);
#define endl '\n' 
using namespace std;
//ifstream fin("datas.in");
//ofstream fout("datas.out");
//#define fin cin
//#define fout cout

const int MAXN = 1002;
char g[MAXN][MAXN];
bool vis[MAXN][MAXN];
int dist[MAXN][MAXN];
int n,m;

int dx[] = {1,-1,0,0};
int dy[] = {0,0,1,-1};

void bfs() {
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=m;j++) {
            dist[i][j] = 0x3f3f3f3f;
        }
    }
    dist[1][1]=0;
    deque<pair<int,int>> dq;
    dq.push_back({1,1});
    vis[1][1]=1;
    while(!dq.empty()) {
        auto [x,y]=dq.front();
        dq.pop_front();
        if(x==n && y==m) return;
        for(int k=0;k<4;k++) {
            int xx=x+dx[k];
            int yy=y+dy[k];
            int cost = g[xx][yy]=='.' ? 0 : 1;
            if(vis[xx][yy]) continue;
            vis[xx][yy]=1;
            if( dist[x][y] + cost < dist[xx][yy]) {
                dist[xx][yy] = dist[x][y]+cost;
                if(cost==0) dq.push_front({xx,yy});
                else dq.push_back({xx,yy});
            }
        }
    }
}

signed main()
{
    IOS
    cin>>n>>m;
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=m;j++) {
            cin>>g[i][j];
        }
    }
    bfs();
    cout<<dist[n][m];
    //fin.close(),fout.close();
    return 0;
}

```