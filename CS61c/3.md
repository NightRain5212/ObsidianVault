
## 程序生成到运行的过程

- 从`c`程序到可执行文件的流程图：
```
C Program (c文件) (example.c) -> Compiler(编译器) ->
Assembly Program (汇编程序文件) (example.s) -> Assembler (汇编器) ->
Object (example.o) (目标文件) -> Linker (连接器) ->
Executale (example.out) (可执行文件) -> Loader (加载器) ->
Memory (内存)
```


## 编译器 & 解释器

- **解释器（Interpreter）** 和**编译器（Compiler）** 是两种将人类编写的高级编程语言（如Python、C++）转换成计算机可以执行的机器代码的核心程序

| 特性    | 编译器 (Compiler)                                                                  | 解释器 (Interpreter)                                                                        |
| ----- | ------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| 翻译方式  | **一次性翻译**：在程序**执行前，将所有源代码完整地转换成目标机器代码**.生成一个独立的可执行文件。                           | **逐行翻译**：在程序**运行时，读取一行源代码，翻译一行**，然后执行一行，不断重复此过程。**不生成独立的可执行文件。**                         |
| 执行速度  | **快。**因为翻译工作已经提前完成，运行时直接执行高效的机器代码，无需再次翻译。                                       | **慢。**每次执行都需要实时进行翻译，这会带来额外的性能开销。                                                         |
| 错误处理  | **编译时报错**：**在编译阶段对整个程序进行语法分析**，如果发现错误，会一次性报告所有语法错误，并且不会生成可执行文件。                 | **运行时报错**：程序会一直执行，**直到遇到错误的那一行代码时才会停止，并报告错误**。无法提前发现后续代码中的错误。                            |
| 平台依赖性 | **依赖平台**。为特定操作系统和CPU架构（如Windows x86）编译的程序，通常无法在其他平台（如macOS ARM）上运行。需要为每个平台单独编译。 | **跨平台**。只要某个平台安装了对应的解释器，同一份源代码就可以直接在该平台上运行，无需修改。例如，同一个Python脚本可以在Windows、macOS和Linux上运行。 |
| 开发周期  | 稍长。**每次修改代码后，都需要重新编译**整个程序才能运行测试，对于大型项目，编译可能需要很长时间。                             | 快。**修改代码后可以立即运行**，省去了编译步骤，非常适合快速原型开发和脚本任务。                                               |
| 典型语言  | C, C++, Rust, Go, Swift                                                         | Python, JavaScript, Ruby, PHP                                                            |

## Compiler 编译器

### 基本功能

- 将高级编程语言（如 C、C++、Java）编写的**源代码**，一次性地完整翻译成计算机中央处理器（CPU）可以直接理解和执行的**汇编语言代码**
- 汇编代码中可能包含了**伪指令**(如：`mv t1,t2 == add t1,t2,x0`)
- 对程序进行编译时，编译器会进行分析，优化，代码生成。

## Assembler 汇编器

### 基本功能

- 将人类可读的汇编文件（`.s` 或 `.asm`）转换成计算机可执行的二进制目标文件（`.o` 或 `.obj`）的。
- 汇编器识别和执行命令，将伪指令`Pseudo-instruction`替换成指令`instruction`，产生机器代码`machine code`。
- 汇编器识别汇编器命令`directive`（`.text`，`.data` 等）时不会产生机器代码。
	- `.text` ：声明“代码段”的开始。 它告诉汇编器：“从这里开始，接下来的内容都是可执行的CPU指令。”
	- `.data`：声明“已初始化数据段”的开始。它告诉汇编器：“从这里开始，接下来的内容是程序需要用到的、并且有初始值的数据。”
	- 等等

####  **两遍扫描法（Two-Pass Assembler）**

- 在代码中，我们可能会跳转或引用一个后面才定义的标签（Label），这被称为“**前向引用”**（Forward Reference）。为了解决这个问题，汇编器采取两边扫描的方法。
	- **第一遍扫描：构建符号表 (Symbol Table Construction)**：在第一次从头到尾读取汇编文件时，汇编器的**唯一目标**是找出文件中定义的所有**标签（Labels）**，并确定它们在内存中的相对地址。它并不会在这一步生成任何机器代码。
	- **第二遍扫描：生成机器代码 (Code Generation)和重定向表**：将每一条汇编指令翻译成二进制的机器码。

#### **符号表**

- 由程序员命名的**符号（Symbol）**（**函数名**，**变量名**，**代码中的任意标签**）和其**详细信息**（**地址，值，大小，类型，绑定属性（全局/本地），所在段（`.data`/ `.text`）**）组成


####  **重定向表**：

- 汇编器在工作时**只了解当前正在处理的这个文件，对其他文件一无所知**，（引用外部符号，引用全局符号的绝对地址时），所以无法生成最终的机器码。它会在机器码中先填入一个临时值（通常是0），然后**创建一个重定位条目**，详细记录下这个“**待办事项**”，交给链接器完成。
- 重定向表包含的信息：
	-  **偏移地址 (Offset)**：指明在**本段（Section）内部**，需要被修正的那个位置的相对地址。
	-  **关联符号 (Symbol)**：一个指向**符号表**的索引，指明本次修正需要用到哪个符号的地址。
	-  **重定位类型 (Type)**：这是最低级、也是最关键的信息。它规定了链接器**如何进行修正**。它不是简单地把地址填进去，而是规定了具体的计算和编码方式。如：
		- `R_RISCV_CALL`：用于 `jal` 指令。告诉链接器计算一个PC相对偏移（`符号最终地址 - 当前指令地址`），然后将这个偏移编码到 `jal` 指令的相应字段中。
		- `R_RISCV_HI20`：用于 `lui` 或 `auipc` 指令。告诉链接器取某个地址的高20位，并填入指令的立即数字段。
		- `R_RISCV_LO12_I`：用于 `addi`、`lw` 等I-Type指令。告诉链接器取某个地址的低12位，并填入指令的立即数字段。

#### **目标文件**

- 目标文件分区如下：
- **目标文件头 (Object file header)**：文件头描述了目标文件中其他部分的大小和位置。
- **文本段 (Text segment)**：这部分包含了程序的机器码。
- **数据段 (Data segment)**：这部分包含了源文件中的数据。它以二进制形式表示了文件中的静态数据
- **重定位信息 (Relocation information)**：这部分信息指出了代码行和需要后续修正的静态数据的二进制表示
- **符号表 (Symbol table)**：符号表列出了该文件中可以被引用的标签和静态数据。
- **调试信息 (Debugging information)**：目标文件还包含用于调试程序的信息。

## 绝对寻址与PC相对寻址

- **PC**：这里的 **PC** 指的是**程序计数器（Program Counter）**，它是CPU内部一个非常重要的寄存器，始终指向**下一条即将被执行的指令**的内存地址。

### 绝对寻址

绝对寻址是一种最直观的内存访问方式。它指的是在机器指令中，直接**硬编码（hardcode）** 一个完整、确切的**虚拟内存地址**来指定操作数或跳转目标。

### PC相对寻址

PC相对寻址不使用固定的绝对地址，而是计算目标地址与**当前指令位置（由程序计数器PC决定）** 之间的**距离（偏移量）**。

### 位置无关代码`PIC`

一段被标记为PIC的代码，意味着**它可以被加载到内存的任意地址并正确执行**。


## Linker链接器

- 链接器的工作流程是**处理一个或多个目标文件，并将它们组合成一个可执行文件**。
- 链接器允许了文件的分离编译，当我们修改文件时，只需要重新编译修改的那个文件，再进行连接即可。而不用重新编译整个项目。

### 工作流程

- **合并所有文本段** (Text Segments)：链接器首先会处理所有输入目标文件中的代码部分 。它会提取出每一个`.o`文件中的文本段（text segment），然后将它们依次拼接在一起，形成一个单一、连续的代码块 。

- **合并所有数据段** (Data Segments)：链接器以类似的方式处理数据部分 。它会提取出每一个`.o`文件中的数据段（data segment），将它们组合在一起，然后附加到刚刚合并好的文本段的末尾 。

- **解析引用** (Resolve References)：链接器需要**修正代码中所有不确定的地址引用**。这个过程通过处理每个文件的**重定位表**（Relocation Table）来完成 。
	- 遍历重定位表中的每一个条目 。对于每个需要解析的引用（标签或数据） ，它会首先在所有用户提供的目标文件的符号表中进行搜索 。如果在用户的符号表中找不到，链接器会接着搜索库文件。
	- 因为**链接器知道每个文本段和数据段的长度以及它们的排列顺序** ，所以它**能够计算出**程序中每一个需要引用的标签（例如函数）和每一块静态数据的**最终绝对地址**

- **重定位**： 一旦某个符号的绝对地址被确定 ，链接器就会用这个地址去“修补”或“填充”机器码中相应的位置 。这个过程就是填充所有绝对地址的过程 。
	- 需要重定位的地址类型包括：**绝对函数地址、外部函数引用以及静态数据引用** 。而**PC相对寻址的地址则不需要重定位** 。


### 静态链接

- 在**编译的链接阶段**，链接器会查找程序所引用的所有函数和变量（例如`printf`）。它会从静态库文件（如`libc.a`）中，提取出`printf`函数以及它所依赖的其他函数的**机器码副本**。
- **打包进可执行文件**：链接器将这些机器码副本与你自己的程序代码（来自`.o`文件）合并在一起，生成一个**单一的、完整的可执行文件**。

#### 特点

- 链接时**将库的内容加入到可执行程序中**的做法。
- 生成的可执行文件是**自给自足的 (self-contained)**。它包含了运行所需的所有代码，**不依赖于外部库文件**。
- **库文件本身成为了可执行文件的一部分。**

#### 优缺点

- **部署简单**：由于可执行文件是自给自足的，你可以把它**拷贝到任何兼容的系统上运行，不用担心目标系统上缺少库文件。**
- **文件体积大**：链接器会**将整个库都包含进来**，即使你的程序只用到了其中的一小部分功能。这会造成磁盘空间的浪费。
- **难以更新**：如果库文件本身有一个安全漏洞被修复了，你的程序不会得到这个更新，因为**它使用的是旧代码的副本**。你**必须重新编译链接整个程序**才能获得修复。
- **内存占用多**：如果多个静态链接的程序同时运行，**每个程序在内存中都有一份库代码的副本，造成内存浪费。**



### 动态链接

