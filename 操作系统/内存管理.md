# 内存

- 内存用于存放数据。程序执行前先放到内存中才能被CPU处理,缓和CPU和外存之间的速度矛盾。
- 内存地址从0开始，每一个地址对应一个存储单元。如果计算机按字节编址，每个存储单元大小为1字节，即8个二进制位。如果计算机**按字编址**，则**每个存储单元大小为一个字**（位数**取决于字长**）
- $2^{10} = 1K ,2^{20} = 1M , 2^{30} = 1G$

# 不同的存储管理模式

 ## **单一连续区存储管理**
 
- 内存被划分为两个固定大小的区域： 
	- **系统区**：仅供操作系统使用，通常位于内存的低地址部分。
	- **用户区**：整个剩余的内存空间，全部分配给一个正在运行的应用程序。
- **任何时候，内存中最多只有一个用户程序。**
- 通常用于单道程序设计环境(**单任务系统**)中，系统只能同时运行一道程序。管理简单，内存利用率低。**有内部碎片**，**无外部碎片**。

![rBWjC9psX1SHakL.png](https://s2.loli.net/2025/11/02/rBWjC9psX1SHakL.png)

## **固定式分区存储管理**

- 在系统启动时，操作系统将用户内存空间**静态地划分**为若干个**大小固定**的分区。每个分区的大小可以相等，也可以不等。
- 当一个作业到达时，系统根据它的大小，将它放入一个**足够容纳它的最小空闲分区**中。
- 会产生**内部碎片**(内零头)：如果作业大小小于所在分区的大小，**该分区内部剩余的空间就被浪费**了。这是固定分区的主要缺点。

![AcbO7WTl9FXzm2H.png](https://s2.loli.net/2025/11/02/AcbO7WTl9FXzm2H.png)
##  **可变式分区存储管理**

- 内存分区不是预先划定的，而是在**作业装入时，根据作业的实际大小动态地创建分区**。
- **没有内部碎片**。
- 会产生**外部碎片**：随着作业的分配和回收，**内存中会出现许多小的、不连续的空闲分区**。虽然它们的总容量可能很大，但**无法分配给任何一个新作业**。这是可变分区的主要缺点。

![1y3kmWAGxNcDj6u.png](https://s2.loli.net/2025/11/02/1y3kmWAGxNcDj6u.png)
##  **可重定位分区存储管理**

-  在可变分区管理的基础上，增加**碎片压缩**功能。
- 当内存中的外部碎片多到无法满足新作业的需求时，操作系统会暂停所有正在运行的程序，**将已分配的分区向内存一端移动**，从而将所有小的外部碎片**合并**成一个大的连续空闲区。
- 由于程序在内存中的位置发生了移动，所以必须**动态重定位**程序的地址。
- **紧凑过程开销巨大**：需要移动大量数据，消耗CPU时间，系统性能会暂时下降。
![WuDEXlPvqpgnaGx.png](https://s2.loli.net/2025/11/02/WuDEXlPvqpgnaGx.png)

# 空闲内存管理


![HjVmTAlkXQJMd9q.png](https://s2.loli.net/2025/10/25/HjVmTAlkXQJMd9q.png)
## 使用位图的存储管理

- **存储空间被分为一系列分配单元**，一个存储分配单元对应于位图中的一位。
- 0表示空闲，1表示占用。
- 分配时,查找位示图中对应位为0的存储块。回收时，将回收的存储块在位示图中所对应的位设置为0。
- 分配单元越小，位示图就越大，管理的开销也越大。

## 使用链表的存储管理

- 使用链表维护已分配内存段和空闲内存段。
- 链表的一个节点可以是一个进程，也可以是两个进程之间的空闲区。
- **节点结构包含**：空闲/进程 指示位，起始地址，长度，下一个节点的指针。
- 节点可以按照地址排序。

# 内存分配算法

## 首次适应算法(*First Fit*）

- 从低地址，按地址顺序依次查找空闲内存区，直到**找到第一个足够大的空闲区**，若空闲区大小大于分配空间，则分为两个部分，一部分被分配，一部分空闲。
- 缺点：会产生**外部碎片**。

## 循环首次适应算法/下次适应算法(*Next Fit*)

- 算法逻辑与首次适应算法相同，但是**每次查找到一个合适的空闲区之后记录此时的位置**。下次寻找空闲区时**从上次结束的地方开始查找**，而不是像首次适应算法那样从头开始。

## 最佳适应算法(*Best Fit*)

- 搜索整个链表，**找到能容纳进程的最小的空闲区**。
- 缺点：会产生很多很小的空闲区。

## 最坏适应算法(*Worst Fit*)

- **总是分配最大的空闲区。**
- 可以使得剩下的空闲区不至于太小。

## 快速适应算法(*Quick Fit*)

- 为常用大小的空闲区维护单独的链表。即**将空闲块按大小分类到不同的链表**中，分配时直接到对应大小的链表中查找，避免遍历所有空闲块。

# 内存回收算法

![WSdqDAevYNKrsBx.png](https://s2.loli.net/2025/10/28/WSdqDAevYNKrsBx.png)

- 当一个进程结束时需要对其分配的内存进行回收，其相邻内存块一共有四种情况。每种情况需单独处理。


# 虚拟内存

- 当需要运行的**程序大小已经大到内存无法容纳**时，虚拟内存应运而生。
- **基本思想**：每个程序都有自己的地址空间，将这个空间分割成若干个块，每一块为一页，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有页必须都在内存中时才能运行程序。当程序需要访问一部分储存在物理内存的地址空间时，在建立映射关系。
- **地址映射**：将程序访问的地址（**虚拟地址**）映射为 实际存储的地址（**物理地址**）

# 地址重定位

- 当一个程序（比如一个C语言源文件）被编译后，它会生成一个目标文件。这个文件中的指令和数据的地址通常是从**零**开始的，我们称之为**逻辑地址**或**相对地址**。
- 然而，当这个程序要被加载到物理内存中运行时，它不可能总是从物理地址0开始。它必须被放入一块空闲的物理内存中，比如从物理地址 `X` 开始。
- **地址重定位** 就是把程序的**逻辑地址**转换为运行时所在的**物理地址**的过程。静态重定位和动态重定位是解决这个问题的两种不同策略。


# 静态重定位

- **静态重定位**：将该程序涉及到的所有地址加上**基地址**（程序在内存中的起始地址），完成地址重定位。
- 静态重定位的地址变换需要在程序运行前完成。在程序加载时完成程序中所有地址项的变换。由操作系统的**加载器** 来完成。
- 缺点：
	- 一旦加载，程序就必须占据一块连续的物理内存，且无法在内存中移动。
	-  操作系统无法阻止程序访问其他程序的内存，因为程序使用的是绝对物理地址。
- 优点
	- 实现简单，在程序执行时没有地址转换的开销。
![ur2qfnBtOoCGQFM.png](https://s2.loli.net/2025/11/02/ur2qfnBtOoCGQFM.png)

# 动态重定位

- 动态重定位的地址变换就在程序运行时进行，在程序加载不需要对程序中的地址项进行地址变换。
- 当程序被调度运行时，操作系统会在一个特殊的CPU寄存器（通常是**基址寄存器**）中设置该程序的**基地址（Base）**。同时，可能还会有一个**界限寄存器**用于内存保护。
-  **硬件地址转换**： 在程序运行过程中，CPU每取一条指令或访问一个数据，发出的都是逻辑地址。**内存管理单元（MMU）** 这个硬件部件会**自动地**将这个逻辑地址与基址寄存器中的值相加，得到真正的物理地址，然后再用这个物理地址去访问内存。
- **物理地址 = 逻辑地址 + 基址寄存器**
- 例如，指令 `JMP 105` 被执行，如果基址寄存器中的值是500，那么MMU会计算 `105 + 500 = 605`，然后去访问物理地址605。
- 缺点：
	- 每次内存访问都需要一次地址加法操作，虽然由硬件完成非常快，但理论上仍存在极小的开销。
- 优点：
	- 可以配合界限寄存器，确保程序不会访问到分配给它的内存区域之外，从而保护操作系统和其他程序。
	- 程序可以在不重启的情况下，在物理内存中移动。
![aWE6e4CwLlFXjfo.png](https://s2.loli.net/2025/11/02/aWE6e4CwLlFXjfo.png)

# 分页机制

##  基本思想

1. **将物理内存**划分为固定大小的、微小的块，称为 **“页框”** 或 **“物理页”**。    
2. **将程序的逻辑地址空间**也划分为**同样**固定大小的块，称为 **“页”** 或 **“虚拟页”**。
3. 程序的“页”可以存放在物理内存中任何一个可用的“页框”里。    
4. 通过一个“**页表**”来记录每个“页”被放到了哪个“页框”里。

![hBkbaDSOueKXN8H.png](https://s2.loli.net/2025/11/02/hBkbaDSOueKXN8H.png)


## 分页流程

-  当一个程序被启动时，操作系统为它创建一个**虚拟地址空间**。这个地址空间是连续的，从0到一个最大值（如4GB）。操作系统将这个连续的虚拟地址空间切割成许多个**页**（例如，每个页大小为4KB）。同时，物理内存也被划分为同样大小的**页框**。
- 操作系统为每个进程创建一个名为 **页表** 的数据结构，建立 **虚拟页** 到 **物理页框** 的映射关系。
- 当CPU执行一条指令，需要访问一个内存地址时，这个地址 `0x1234` 是一个**虚拟地址**。CPU必须通过**内存管理单元（MMU）** 将它转换成**物理地址**。

![AIT5JP1qfOeMW26.png](https://s2.loli.net/2025/11/02/AIT5JP1qfOeMW26.png)

- 程序访问了一个“合法”但“未加载入内存”的虚拟地址时，硬件触发**缺页异常**。

##  **缺页异常**

- MMU在地址转换过程中发现目标页的页表项有效位为0，会立即触发缺页异常。
- 然后操作系统需要找到一个空闲的**物理页框**来存放即将被加载的页面。**如果系统有空闲页框**：直接从空闲链表中取一个。 **如果没有空闲页框**：则必须执行**页面置换算法**（如LRU、Clock算法等），选择一个当前在内存中的页面作为 **“牺牲者”**。
- 接着将所需的页面数据从磁盘**读入**到分配好的物理页框中。
- 再**更新当前进程的页表**，修改映射关系。然后重新启动引起中断的指令。

![W2bTM14mnvKeChf.png](https://s2.loli.net/2025/11/02/W2bTM14mnvKeChf.png)

# 页表

- 在分页系统中，程序的地址空间（虚拟地址空间）被划分为固定大小的**页**，物理内存被划分为同样大小的**页框**。一个程序的虚拟页可以分散地存放在任何可用的物理页框中。
- **页表就是记录这种“分散存放”关系的“地图”或“地址簿”**。
- 页表本质上是一个存储在内存中的**数组**。这个数组的**索引**是**虚拟页号**，数组的**内容**是**页表项**。
- 地址转换过程：
	1. MMU将虚拟地址拆分为`虚拟页号 (VPN)`和`页内偏移量 (Offset)`。
	2. 以 `VPN` 作为索引，在页表数组中找到对应的页表项（PTE）。
	3. 从页表项中取出`物理页框号 (PFN)`。
	4. 将 `PFN` 和 `Offset` 拼接，得到物理地址。

## 页表项

- 页表项的结构有：页框号，存在位，保护位，修改位，访问位，高速缓存禁止位。

![Vmtf9cJw8pn2BQu.png](https://s2.loli.net/2025/11/02/Vmtf9cJw8pn2BQu.png)

- **存在位**：
	- 表示该页是否在物理内存中。1表示该页在物理内存中；0表示不在。访问一个P=0的页会触发**缺页异常**。
- **保护位**：
	- **控制对页面的访问权限**，保障系统和进程的安全。用于指定该页面是否可读、可写、可执行。
- **修改位**：
	- **记录页面自被加载到内存后是否被写入过**。这个位也常被称为**脏位**。
	- 当页面首次被载入内存时，CPU会将此位设置为 **0**。
	- 当有任何指令（如`MOV`, `STORE`）**写入**该页面时，CPU的MMU硬件会自动将此位置 **1**。记录该页面被修改过，便于后面置换使用。
	- 当操作系统需要将此页面换出内存以腾出空间时，它会检查修改位：
	    - 如果为 **1**（脏页），说明**页面的内存副本比磁盘副本新**，操作系统**必须将该页面写回磁盘**。
	    - 如果为 **0**（干净页），说明**磁盘上的副本仍然是最新的**，操作系统**可以直接丢弃**内存中的页面，无需执行耗时的磁盘写操作。
- **访问位**：
	- **记录页面近期是否被访问过（读或写）**。
	- **主要用途**：为**页面置换算法**（如LRU的近似算法）提供决策依据。
- **高速缓存禁止位**：
	- **控制该页面对应的物理内存是否可以被CPU高速缓存**。

# 快表

- 由于计算机程序有一个现象：大多数程序总是对少量的页面进行多次的访问，而不是相反。因此，只有很少的页表项会被反复读取，而其他的页表项很少被访问。
- 所以为计算机设置一个小型硬件设备，将虚拟地址直接映射到物理地址，而不必访问页表。这个设备为**转换检测缓冲区** *(TLB)*，也称**快表**。
- 目的：**缓存最近使用过的虚拟页到物理页框的映射关系**。
- 它通常存在于MMU中，包含少量的表项。
- 一个表项包含：
    - **标签**：存储的是**虚拟页号** 的一部分。
    - **数据**：存储的是对应的**物理页框号**，以及从原始页表项中复制过来的**保护位、有效位、脏位**等控制信息。
![4InVSwuqQgcCOe9.png](https://s2.loli.net/2025/11/02/4InVSwuqQgcCOe9.png)

- 工作流程：
	- 将一个虚拟地址进入MMU进行转换时，同时查找TLB中所有表项进行匹配，判断虚拟页面是否存在其中。
	- 如果匹配有效而且不违反保护位，则直接从TLB取出页框号，不必访问页表。
	- 如果无有效匹配，就进行页表查询。然后在TLB中淘汰一个表项，用找到的新页表项代替。
![huwrHOSiF4KqmMT.png](https://s2.loli.net/2025/11/02/huwrHOSiF4KqmMT.png)


# 页面置换算法

- **定义**：缺页时如果没有空闲块，则要选择一个合适的页面置换。
- **已修改过**的页面在被置换前应**先保存到外存**，而没有修改过的页面只是简单地覆盖。

## 最近未使用页面置换算法NRU（Not Recently Used）

- 每个页面都有**访问位(Reference bit)** 和**修改位(Modified bit)**
- 一个页面**被访问时**，其**访问位被置为1**；一个页面**被修改后其修改位被置为1**。
- 页面的**访问位定期地**(如每隔20ms)**被清为0**，所以如果一个页面的访问位为0，则表示该页面在**最近一个时钟周期没有被访问过**。
- 所以一个页面有四种情况（RM位）：
	1. 没有被访问，没有被修改
	2. 没有被访问，已经被修改
	3. 已被访问，没有被修改
	4. 已被访问，已被修改
- **NRU**(*Not Recently Used*)算法随机地从编号最小的一类中选一个页面淘汰。

## 时钟页面置换算法Clock

- 把所有页面放入类似于时钟的一个环形链表中。表针指向最老的页面。
- 发生缺页中断时，每次检查表针的页面，如果R位是0则淘汰，将新的页面插入这个位置，将表针向前移动一个位置；否则，清除该页面R位，将表针向前移动一个位置，直到找到R位是0的页面。

![JlOV8EfCQjk36Dd.png](https://s2.loli.net/2025/11/02/JlOV8EfCQjk36Dd.png)

## 先进先出页面置换算法FIFO

- **基本思想**：**优先淘汰最早进入的页面。**
- 维护一个当前内存所有页面的链表，最新进入的页面放在表尾，最早进入的放在表头。当缺页中断时，淘汰表头的页面，将新页面放在表尾。

## 第二次机会页面置换算法

- 按先进先出页面置换的思路维护一个链表（最新进入的页面放在表尾，最早进入的放在表头）
- 每次缺页中断时，检查最老页面的R位，如果是0，直接淘汰；如果是1，则将R位清零，并放到链表的尾端。
- 第二次机会算法就是寻找一个**在最近的时钟间隔内没有被访问过的页面**。如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。
![WAI5pXHnTgKk8Oe.png](https://s2.loli.net/2025/11/02/WAI5pXHnTgKk8Oe.png)

## 最优页面置换算法OPT（Optimal）

- **算法思想**：将每个页面在该页面下次被访问前所要执行的指令次数作为标记，每次置换标记最大（标记大，说明要先执行更多的指令之后访问此页面）的页面。
- **优先淘汰未来最长时间内不会再被访问的那一页。**
- opt需要**提前知道未来的访问序列**，在实际系统中**不可能实现**。
	
## 最近最少使用页面置换算法LRU(Least Recently Used)

- **基本思想**：**优先淘汰最长时间没有被使用的页面。**
- LRU在理论上可以实现，但代价很高。
- 维护一个所有页面的链表，表头为最近最多使用的页面，表尾为最近最少使用的页面。每次访问内存时要更新整个链表。（找到该节点移动到表头的开销很大）      

## 软件模拟LRU

### **最不常用页面置换算法NFU**(Not Frequently Used)

- 每个页面有一个关联的软件计数器
- 操作系统**定期扫描每个页面**，将页面的**R位的值累加于对应的计数器**，所以**计数器值最大的页面表示访问次数最多的页面**。
- **优先置换计数器值最小的页面**

#### **缺陷**

- 历史访问无法被“遗忘”，早期频繁的访问对现在仍有较大影响。NFU **对“近期访问”不敏感**。

### **老化算法**(Aging)

- 用一个带“衰减”的计数器来**逼近 LRU**（Least Recently Used）算法。
- 每个页面维护一个 8 位（固定位数）的计数器。
- 每个时钟中断（例如每 20ms）执行以下操作：
	- **将每个页面的计数器右移一位**，这代表旧的访问“逐渐变得没那么重要”
	- 若页面在本周期被访问（R=1），则将计数器的最高位置为 1
	- 清除R位
![ZplUCIHRDNOwKPb.png](https://s2.loli.net/2025/11/30/ZplUCIHRDNOwKPb.png)

- counter 的位结构相当于“访问历史的滑动窗口”，counter 记录了过去 N 个时间片的访问历史，且**越老访问所占的权重越低**，**N个时间片之前的访问历史被遗忘。**


## 工作集页面置换算法（Working Set）

### **工作集与颠簸**

- 一个进程**当前正在使用的页面的集合**称为它的工作集。
- 根据局部性原理可知：如果整个工作集都被装入到了内存中，那么进程在运行到下一运行阶段（例如，编译器的下一遍扫描）之前，不会产生很多缺页中断。
- 若内存太小而无法容纳下整个工作集，那么进程的运行过程中会产生大量的缺页中断，导致运行速度也会变得很缓慢。
- 若每执行几条指令程序就发生一次缺页中断，那么就称这个程序发生了**颠簸**。

### **工作集模型**

- 所以不少分页系统都会设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已在内存中了。该方法称为**工作集模型**，其目的在于大大减少缺页中断率。在进程运行前预先装入其工作集页面也称为**预先调页**。请注意工作集是随着时间变化的。
- 在任一时刻$t$，都存在一个集合，它包含**所有最近k次内存访问所访问过的页面**。这个集合$w(k,t)$就是工作集。
- 因为最近$k=1$次访问肯定会访问最近$k>1$次访问所访问过的页面，所以$w(k,t)$是$k$的单调非递减函数。
- 随着$k$的变大，$w(k,t)$是**不会无限变大**的，因为程序不可能访问比它的地址空间所能容纳的页面数目上限还多的页面，并且几乎没有程序会使用每个页面。
![qDb9Gpa5wHC2zVt.png](https://s2.loli.net/2025/11/02/qDb9Gpa5wHC2zVt.png)

### **工作集页面置换**

- 目标是动态地确定每个进程的工作集，并确保只有属于工作集的页面才保留在内存中。找出不属于工作集的页面并淘汰。
- 需要为每个页表项增加两个字段：
	1. **上次使用时间**：记录该页面最后一次被访问（读或写）的时间戳。
	2. **访问位**：记录页面近期是否被访问过
- **在处理每个表项时，都需要检查R位**。
- 如果它是1，就把当前实际时间写进页表项的“上次使用时间”域，以**表示缺页中断发生时该页面正在被使用**。既然该页面在当前时钟滴答中已经被访问过，那么很明显**它应该出现在工作集中，并且不应该被删除**。
- 如果它是0，那么表示在当前时钟滴答中，该页面还没有被访问过，则它就可以作为候选者被置换。为了知道它是否应该被置换，需要**计算它的生存时间**（即**当前实际运行时间减去上次使用时间**），然后与做比较。**如果它的生存时间大于 $\tau$ ,那么这个页面就不再在工作集中，而用新的页面置换它。** 扫描会继续进行以更新剩余的表项。
- 然而，如果R是0同时生存时间小于或等于τ，则该页面仍然在工作集中。这样就要把该页面临时保留下来，但是要记录生存时间最长(“上次使用时间”的最小值)的页面。
- 如果**扫描完整个页表却没有找到适合被淘汰的页面**，也就意味着所有的页面都在工作集中。在这种情况下，如果找到了一个或者多个R=0的页面，就**淘汰生存时间最长的页面**。在最坏情况下，在当前时间滴答中，所有的页面都被访问过了（也就是都有R=1),因此就随机选择一个页面淘汰，如果有的话最好选一个干净页面。

![3uWj94mzZQH2RxO.png](https://s2.loli.net/2025/11/30/3uWj94mzZQH2RxO.png)

## 工作集时钟页面置换算法(WSClock)

- WSClock 使用 **一个环形链表**（时钟结构）维护页面，每个页面记录信息：`R`位（访问位），`Dirty`位（修改位），`lut`（上次使用时间 $\tau$）
- 全局变量，**工作集窗口** $\Delta$，如 200ms、1s，用来评估页面是否属于工作集
- 如果一个页面长时间没有被访问（$CurrentTime - τ > Δ$），说明它已经不属于工作集，应该被淘汰。
- 时钟指针指向页面P，
	- R=1，清除R，指针前进
	- R=0，检查页面是否在工作集中，若在工作集指针前进，否则检查修改位
		- 页面未修改，淘汰
		- 页面已修改，将页面异步写回磁盘，指针前进
- 如果一圈都没找到可淘汰页面，可以选择一个已经写回的脏页，或第一个R=0的脏页


# 多级页表

- 当虚拟地址空间十分巨大的时候，可以使用多级页表处理大内存的页表。

## 二级页表

![nrKY7JNRPgLyI4a.png](https://s2.loli.net/2025/11/02/nrKY7JNRPgLyI4a.png)

- 将32位的虚拟地址分为3部分：PT1(10)+PT2(10)+OFFSET(12)
- 二级页表分为顶级页表和二级页表，其中二级页表的每一项都对应$2^{12}=4KB$的地址块，顶级页表的每一项都对应一个二级页表的索引，对应$2^{22}=4MB$的地址空间。
- 该二级页表一共管理了$2^{20}$个页面。
- 顶级页表共有$1024$个表项，对应于虚拟地址的PT1部分。
- 二级页表同理，对应于虚拟地址的PT2部分。
- 将虚拟地址转化为物理地址的流程：取虚拟地址的PT1部分，以此为索引查询顶级页表，得到对应的二级页表号。取虚拟地址的PT2部分，以此为索 引查询二级页表，得到对应的物理地址块（对应页框号），加上偏移量得到物理地址。

# 分段机制

![nJgLmPMV7HatDY4.png](https://s2.loli.net/2025/11/02/nJgLmPMV7HatDY4.png)

- **基本思想**：**按程序自然逻辑结构分段**，每个分段作为一个独立分配单位，可以离散地分配到内存中。
- **核心思想：一个程序的内存空间应该由多个逻辑上独立的单元组成，每个单元对应一个逻辑段**。
- 一个程序可以由几个段组成：
	- **代码段**：存放程序的指令。
	- **数据段**：存放全局变量、静态变量。
	- **堆栈段**：存放函数调用栈、局部变量。
	- 可能还有**堆段**、**命令行参数段**等。
- 分段式内存管理就是将程序的这些**逻辑段**作为内存分配和管理的单位。每个段都有自己的名字、长度和属性。

## 工作原理

![AteIxSnVviRXo9j.png](https://s2.loli.net/2025/11/02/AteIxSnVviRXo9j.png)

![Uy6VwWtX2xlTRgB.png](https://s2.loli.net/2025/11/02/Uy6VwWtX2xlTRgB.png)

- 在分段系统中，一个虚拟地址不再是单一的一个地址，而是由两部分组成：
	- **段号**：指定了是哪个段（如代码段、数据段）。
	- **段内偏移量**：指定了在该段内部的哪个位置。
- 操作系统为每个进程维护一个**段表**。段表建立了**逻辑段与物理内存区域的映射关系。**
- **段表项的结构**
	- **段基址**：该段在物理内存中的起始地址。
	- **段长**：该段的实际长度。
	- **保护位**：该段的访问权限（如：可读、可写、可执行）。
	- **存在位**：表示该段是否已加载到内存中。
	- **修改位**、**访问位**等。
- **工作流程**：
	- 当CPU执行一条指令，需要访问虚拟地址 `(s, d)` 时
	-  **MMU** 使用**段号 s** 作为索引，查找进程的**段表**，找到第 s 个段表项。
	- **检查合法性**：偏移量检查，检查是否越界访问；权限检查，检查操作（读/写/执行）是否与段表项中的**保护位**匹配
	- 如果检查通过，MMU 将**段基址**（段的起始物理地址）与**段内偏移量 d** 相加，得到最终的**物理地址**。
- **优点**：
	- 分段系统没有内零头，但会出现外零头。
	- 分段是根据程序的自然逻辑结构形成的，有利于程序和数据的共享。

# 分段与分页的区别与联系

- 分段系统和分页系统都是**离散式的存储管理方式**，都能较好地支持虚拟存储技术。
- **划分不同**：
	- 分页是对目标代码的逻辑地址**按页面大小机械地划分**形成
	- 分段则是**根据程序的自然逻辑结构而形成**的，更利于程序和数据的共享。
- **零头/碎片不同：**
	- **分段系统没有内零头**，但**会出现外零头**；
	- **分页系统没有外零头**，但一个进程的**最后一页所在物理块可能会出现内零头**。
- 因为分段一般比较大，所以分段系统的内存利用率没有分页系统高。

# 段页式存储管理

- **基本思想**：**先分段，再分页**。**按进程的自然逻辑结构分段，段内分页。**
![G8RbSwsy2gq7CNd.png](https://s2.loli.net/2025/11/02/G8RbSwsy2gq7CNd.png)
## 工作原理

### **地址结构**

- 在段页式系统中，一个虚拟地址（或逻辑地址）由三部分组成：
	- **段号**：指定是哪个逻辑段。
	- **页号**：指定在该段中的哪一页。
	- **页内偏移量**：指定在该页内的具体位置。

### **段表页表**

- **段表**：每个进程一个段表。它的作用不再是直接指向物理内存的基址，而是**指向该段的页表。**
- **段表项**包含：该段页表的**起始物理地址**、该段的**长度**、**保护位**等。

- **页表**：**每个段一个页表**。它的作用和纯分页系统中的页表一模一样，将虚拟页号映射到物理页框号。
- **页表项**包含：**物理页框号**、**存在位**、**修改位**、**保护位**等。

### **地址转换过程**

- MMU接受逻辑地址，使用虚拟地址中的 **段号 s**，找到进程段表中的第 s 个**段表项**。
-  **段级检查**：进行段级的**保护和越界检查**（例如，检查页号p是否超出了段的长度范围）。
- **找到页表**：从段表项中取出该段的**页表起始物理地址**。
-  **查找页表**：MMU使用虚拟地址中的 **页号 p** 作为索引，在刚刚找到的页表中，定位到第 p 个**页表项**。
- **页级检查**：检查页表项中的存在位和保护位。
- **合成物理地址**：从页表项中取出**物理页框号 f**，与虚拟地址中的 **页内偏移量 d** 拼接，形成最终的**物理地址**。
![hETJlmK7RNykSC8.png](https://s2.loli.net/2025/11/02/hETJlmK7RNykSC8.png)

## 优点

- 可以充分利用小的空闲区，避免分段系统中拼接的开销；又支持进程的自然逻辑结构，便于程序与数据的共享。**逻辑清晰，易于共享和保护（分段的优点）**。
- **没有外部碎片（分页的优点）**

## 缺点

- **地址转换开销大**：理论上，一次内存访问需要**三次**访存：访问段表，访问页表，访问目标指令或数据。


